---
title: "Eelgrass_community_structure_analyses"
author: "Wendel Raymond"
date: "January 16, 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r libraries, echo = FALSE, message = FALSE, warning = FALSE}
library(ggplot2)
library(dplyr)
library(lattice)
library(coda)
library(boot)
library(parallel)
library(rjags)
library(runjags)
library(loo)
library(DT)
library(cowplot)

theme_set(theme_classic())
```


# Analyses for testing hypotheses related to eelgrass community structure
**Question** 
What is the structure of eelgrass communities across a gradient of sea otter impacts?

**Overall Hypothesis**
If top-down (sea otter) forces are structuring eelgrass communities, then we would expect alternating relative abundance from trophic level to trophic level.

## Outline
1. Description of data
2. Testing assumptions
    + normality
    + co-linearity
3. Models

## 1. Data
**Response metrics**
1. eelgrass aboveground biomass density (g / m^2^)
2. eelgrass belowground biomass density (g / m^2^)
3. eelgrass shoot density (count / m^2^)
4. ratio of aboveground to belowground biomass density (g / m^2^)
5. epiphyte load (g epiphyte / g eelgrass)
6. total grazer load (g grazers/ g eelgrass)
    + gastropod load (g grazers/ g eelgrass)
    + crustaecean load (g grazers/ g eelgrass)
7. crab biomass (g)
8. fish standarized by ... candidates are length, gape size, biomass

**Primary explanatory factors**
Not all these fators will necessarily be used in all models
1. Time
2. Sediment type (primary sediment type from the "inside" eelgrass transect)
3. Percent light

**Secondary explanatory factors**
Factors that are more specific to certain tests
1. crab biomass (g)
2. fish

```{r import data, echo = FALSE, message = FALSE, warning = FALSE}
tran.dat <- read.csv( "../ALL_DATA/eelgrass_bio_sed_transect_derived.csv", header = TRUE, stringsAsFactors = FALSE)

crab.dat <- read.csv("../All_DATA/eelgrass_crab_pot_derived.csv", header = TRUE, stringsAsFactors = FALSE)
```

## 2. Testing assumptions

### Normality
Response metrics should have approximatley normal distribution. For this exploration we can omit the NA rows that allowed for merging with sediment data. We will also omit the April sites (L01 and H01). Resulting data frame should have 19 X 9 rows = 152. For the crab data we also want to omit the April sites. Initially we will also want to sum crab biomass within each string (pool over species). The imported data is not set up this way so the data will we summarised as such. The imported crab data is fairly bare, in that it only has the site name, date, and soak time. Data will need to be merged with sea otter index, and other things for formal analysis.
```{r data edit}
#tran.dat <- tran.dat %>% 
  #filter(site != "2017_L_01" & site != "2017_H_01") %>% 
  #filter(quadrat < 9)

#crab <- crab.dat %>% 
  #filter(site != "2017_L_01" & site != "2017_H_01") %>% 
  #group_by(site, string) %>% 
  #summarise(mass_g = sum(mass_g))

#crab.dat <- merge(unique(crab.dat[, 1:8]), crab, by = "site", all.y = TRUE)
```

Eelgrass shoot density appears reasonably normal but fails SW test. Further test indicate that sqrt transformation achives normality.
```{r shoot dens normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(eelgrass_shoots_msq)) +
  geom_histogram(bins = 10) +
  labs(x = "Eelgrass shoot density", y = "Counts")

qqnorm(tran.dat$eelgrass_shoots_msq)
qqline(tran.dat$eelgrass_shoots_msq, lwd = 2)

shapiro.test(tran.dat$eelgrass_shoots_msq)

## ln transformation ##
ggplot(tran.dat, aes(log(eelgrass_shoots_msq))) +
  geom_histogram(bins = 10) +
  labs(x = "log Eelgrass shoot density", y = "Counts")

qqnorm(log(tran.dat$eelgrass_shoots_msq))
qqline(log(tran.dat$eelgrass_shoots_msq), lwd = 2)

shapiro.test(log(tran.dat$eelgrass_shoots_msq))

## sqrt transfrormation ##
ggplot(tran.dat, aes(sqrt(eelgrass_shoots_msq))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt Eelgrass shoot density", y = "Counts")

qqnorm(sqrt(tran.dat$eelgrass_shoots_msq))
qqline(sqrt(tran.dat$eelgrass_shoots_msq), lwd = 2)

shapiro.test(sqrt(tran.dat$eelgrass_shoots_msq))
```

Aboveground biomass shows some right skewness suggesting ln transformation. Log transformation was not super great. However square roor transformation appears more helpful. SW tests all indicate at least some non-normality, but sqrt transformation is the best.
```{r ag normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(ag_mass)) +
  geom_histogram(bins = 10) +
  labs(x = "Aboveground biomass", y = "Counts")

qqnorm(tran.dat$ag_mass)
qqline(tran.dat$ag_mass, lwd = 2)

shapiro.test(tran.dat$ag_mass)

## ln transformed ##
ggplot(tran.dat, aes(log(ag_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "log Aboveground biomass", y = "Counts")

qqnorm(log(tran.dat$ag_mass))
qqline(log(tran.dat$ag_mass), lwd = 2)

shapiro.test(log(tran.dat$ag_mass))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(ag_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt Aboveground biomass", y = "Counts")

qqnorm(sqrt(tran.dat$ag_mass))
qqline(sqrt(tran.dat$ag_mass), lwd = 2)

shapiro.test(sqrt(tran.dat$ag_mass))
```

Belowground biomass also shows right skewness. Both log and square root tranformations improve normality. SW test indicates that log transformation achieves normality.
```{r bg normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(bg_mass)) +
  geom_histogram(bins = 10) +
  labs(x = "Belowground biomass", y = "Counts")

qqnorm(tran.dat$bg_mass)
qqline(tran.dat$bg_mass, lwd = 2)

shapiro.test(tran.dat$bg_mass)

## ln transformed ##
ggplot(tran.dat, aes(log(bg_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "log Belowground biomass", y = "Counts")

qqnorm(log(tran.dat$bg_mass))
qqline(log(tran.dat$bg_mass), lwd = 2)

shapiro.test(log(tran.dat$bg_mass))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(bg_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt belowground biomass", y = "Counts")

qqnorm(sqrt(tran.dat$bg_mass))
qqline(sqrt(tran.dat$bg_mass), lwd = 2)

shapiro.test(sqrt(tran.dat$bg_mass))
```

Ratio of above to belowground biomass also appears right skewed. SW test indicates that log transformation is best.
```{r agbg normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(ag_mass / bg_mass)) +
  geom_histogram(bins = 10) +
  labs(x = "AG:BG biomass", y = "Counts")

qqnorm(tran.dat$ag_mass / tran.dat$bg_mass)
qqline(tran.dat$ag_mass / tran.dat$bg_mass, lwd = 2)

## ln transformed ##
ggplot(tran.dat, aes(log(ag_mass / bg_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "log AG:BG biomass", y = "Counts")

qqnorm(log(tran.dat$ag_mass / tran.dat$bg_mass))
qqline(log(tran.dat$ag_mass / tran.dat$bg_mass), lwd = 2)

shapiro.test(log(tran.dat$ag_mass / tran.dat$bg_mass))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(ag_mass / bg_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt AG:BG biomass", y = "Counts")

qqnorm(sqrt(tran.dat$ag_mass / tran.dat$bg_mass))
qqline(sqrt(tran.dat$ag_mass / tran.dat$bg_mass), lwd = 2)

shapiro.test(sqrt(tran.dat$ag_mass / tran.dat$bg_mass))
```

Epiphyte load. This one is a bit tricky, any sort of tranformation does not deal with the outliers well. 
```{r epi load normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(epimass_shootmass)) +
  geom_histogram(bins = 10) +
  labs(x = "Epiphyte load", y = "Counts")

qqnorm(tran.dat$epimass_shootmass)
qqline(tran.dat$epimass_shootmass, lwd = 2)

## ln transformed ##
ggplot(tran.dat, aes(log(epimass_shootmass + 0.1))) +
  geom_histogram(bins = 10) +
  labs(x = "log Epiphyte load", y = "Counts")

qqnorm(log(tran.dat$epimass_shootmass + 0.1))
qqline(log(tran.dat$epimass_shootmass + 0.1), lwd = 2)

shapiro.test(log(tran.dat$epimass_shootmass + 0.1))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(epimass_shootmass))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt Epiphyte load", y = "Counts")

qqnorm(sqrt(tran.dat$epimass_shootmass))
qqline(sqrt(tran.dat$epimass_shootmass), lwd = 2)

shapiro.test(sqrt(tran.dat$epimass_shootmass))
```

Grazer load does not respond well to any transformation. Given the distribution of the raw data it may be best to keep it the way it is.
```{r grazer load normality, echo=FALSE}
## raw data ##
ggplot(tran.dat, aes(grazmass_shootmass)) +
  geom_histogram(bins = 20) +
  labs(x = "Grazer load", y = "Count")

## ln transformation ##
ggplot(tran.dat, aes(log(grazmass_shootmass + 0.1))) +
  geom_histogram(bins = 10) +
  labs(x = " log Grazer load", y = "Count")

shapiro.test(log(tran.dat$grazmass_shootmass + 0.1))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(grazmass_shootmass))) +
  geom_histogram(bins = 10) +
  labs(x = " sqrt Grazer load", y = "Count")

shapiro.test(sqrt(tran.dat$grazmass_shootmass))
```

Gastropod load also does not respond super well to transformations.
```{r gastropod load normality, echo=FALSE}
## raw data ##
ggplot(tran.dat, aes(gastromass_shootmass)) +
  geom_histogram(bins = 20) +
  labs(x = "Grazer load", y = "Count")

## ln transformation ##
ggplot(tran.dat, aes(log(gastromass_shootmass + 0.1))) +
  geom_histogram(bins = 10) +
  labs(x = " log Grazer load", y = "Count")

shapiro.test(log(tran.dat$gastromass_shootmass + 0.1))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(gastromass_shootmass))) +
  geom_histogram(bins = 10) +
  labs(x = " sqrt Grazer load", y = "Count")

shapiro.test(sqrt(tran.dat$gastromass_shootmass))
```

Crustacean load also does not respond super well to transformations.
```{rcrusteacean load, echo=FALSE}
## raw data ##
ggplot(tran.dat, aes(crustmass_shootmass)) +
  geom_histogram(bins = 20) +
  labs(x = "Grazer load", y = "Count")

## ln transformation ##
ggplot(tran.dat, aes(log(crustmass_shootmass + 0.1))) +
  geom_histogram(bins = 10) +
  labs(x = " log Grazer load", y = "Count")

shapiro.test(log(tran.dat$crustmass_shootmass + 0.1))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(crustmass_shootmass))) +
  geom_histogram(bins = 10) +
  labs(x = " sqrt Grazer load", y = "Count")

shapiro.test(sqrt(tran.dat$crustmass_shootmass))
```

Crab biomass does not respoond super well to any transformations. There are a fair amount of zeros which is messing with normality. This data may need to be modeled with a zero infalted model, or something like that. But the zeros are also really important to be zeros. 
```{r crab biomass normality, echo=FALSE}
## Raw data ##
ggplot(crab.dat, aes(mass_g)) +
  geom_histogram(bins = 20) +
  labs(x = "crab mass", y = "Count")

## ln transformation ##
ggplot(crab.dat, aes(log(mass_g + 1))) +
  geom_histogram(bins = 20) +
  labs(x = "log crab mass", y = "Count")

shapiro.test(log(crab.dat$mass_g + 1))

## sqrt transformation ##
ggplot(crab.dat, aes(sqrt(mass_g))) +
  geom_histogram(bins = 20) +
  labs(x = "sqrt crab mass", y = "Count")

## Raw data > 0 ##
crab.dat.noZ <- crab.dat %>%
  filter(mass_g > 0)
  
ggplot(crab.dat.noZ, aes(mass_g)) +
  geom_histogram(bins = 20) +
  labs(x = "non zero crab mass", y = "Count")

## ln transformation > 0 ##
ggplot(crab.dat.noZ, aes(log(mass_g))) +
  geom_histogram(bins = 20) +
  labs(x = "log non zero crab mass", y = "Count")

## sqrt transformation > 0 ##
ggplot(crab.dat.noZ, aes(sqrt(mass_g))) +
  geom_histogram(bins = 20) +
  labs(x = "sqrt non zero crab mass", y = "Count")
```

## 3. Models
Each model will get its own individual hypothesis and set up but will follow the same general framework. Initially I will be copying and learning from example code from Tim Tinker. Models will use a mixed effects Bayesian modeling stucture. Fixed effects and the random effect of site will be modeled with normally distribution density funtions. Response variables will be paramterized in a way that best fits their distribution (see above). Count data (shoot density) will be modeled with a negative binomial distrbution. 

Models will exclude the two sites sampled in April. If the data have not already been excluded do that here.
```{r exclude april, echo=FALSE}
#tran.dat <- tran.dat %>% 
  #filter(site != "2017_L_01" & site != "2017_H_01")
```


### Model 1 - Aboveground biomass
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, sediment type, and light attenuation may effect aboveground biomass of eelgrass. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900.  

```{r Model 1 set up, echo=FALSE}
# Dependent observed variable: this should be whatever numeric variable you wish to analyze 
Obs <- as.numeric(tran.dat$ag_mass)

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Sedtype <- as.numeric(tran.dat$sed1_no)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Light <- as.numeric(tran.dat$light_attenu)[ii]
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting attributes of data
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.1 <- data.frame(Model = c("Model_1a","Model_1b","Model_1c","Model_1d","Model_1e","Model_1f","Model_1g", "Model_1h"), 
                        WAIC = numeric(length = 8), 
                        LOOIC = numeric(length = 8))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 1a
Aboveground biomass ~ time
```{r model 1a, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_1a.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx) #, Ott = Ottindx, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1a <- WAIC
ModComp.1$WAIC[1] <- WAIC1a$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1a <- LOOIC
ModComp.1$LOOIC[1] <- LOOIC1a[3]

# WAIC Detail
WAIC.1a <- data.frame(modID = c('WAIC1a'), model = c('1a'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1a <- data.frame(modID = c('LOOIC1a'), model = c('1a'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1a <- out
```
 
#### Model 1b
Aboveground biomass ~ time + SOI
```{r model 1b, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1b.jags'
# savename='EelgrassM1b_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1b <- WAIC
ModComp.1$WAIC[2] <- WAIC1b$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1b <- LOOIC
ModComp.1$LOOIC[2] <- LOOIC1b[3]

# WAIC Detail
WAIC.1b <- data.frame(modID = c('WAIC1b'), model = c('1b'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1b <- data.frame(modID = c('LOOIC1b'), model = c('1b'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1b = out
```

#### Model 1c
Aboveground biomass ~ time + SOI + sediment
```{r model 1c, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1c.jags'
# savename='EelgrassM1c_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum,Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1c <- WAIC
ModComp.1$WAIC[3] <- WAIC1c$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1c <- LOOIC
ModComp.1$LOOIC[3] <- LOOIC1c[3]

# WAIC Detail
WAIC.1c <- data.frame(modID = c('WAIC1c'), model = c('1c'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1c <- data.frame(modID = c('LOOIC1c'), model = c('1c'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1c = out
```

#### Model 1d
Aboveground biomass ~ time + SOI + sediment + light
```{r model 1d, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1d.jags'
# savename='EelgrassM1d_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Li = Light) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3", "beta4", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method ="rjparallel", cl=cl)

post <- rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post <- rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1d <- WAIC
ModComp.1$WAIC[4] <- WAIC1d$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1d <- LOOIC
ModComp.1$LOOIC[4] <- LOOIC1d[3]

# WAIC Detail
WAIC.1d <- data.frame(modID = c('WAIC1d'), model = c('1d'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1d <- data.frame(modID = c('LOOIC1d'), model = c('1d'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1d = out
```

#### Model 1e
Aboveground biomass ~ time + quad(SOI)
```{r model 1e, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1e.jags'
# savename='EelgrassM1d_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method ="rjparallel", cl=cl)

post <- rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post <- rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1e <- WAIC
ModComp.1$WAIC[5] <- WAIC1e$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1e <- LOOIC
ModComp.1$LOOIC[5] <- LOOIC1e[3]

# WAIC Detail
WAIC.1e <- data.frame(modID = c('WAIC1e'), model = c('1e'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1e <- data.frame(modID = c('LOOIC1e'), model = c('1e'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1e = out
```

#### Model 1f
Aboveground biomass ~ time + quad(SOI) + sediment
```{r model 1f, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1f.jags'
# savename='EelgrassM1f_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) # Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","beta3","eps","loglik") 

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC1f = WAIC
ModComp.1$WAIC[6] = WAIC1f$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1f <- LOOIC
ModComp.1$LOOIC[6] <- LOOIC1f[3]

# WAIC Detail
WAIC.1f <- data.frame(modID = c('WAICf'), model = c('1f'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1f <- data.frame(modID = c('LOOIC1f'), model = c('1f'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1f = out
```

#### Model 1g
Aboveground biomass ~ quad(time) + SOI
```{r model 1g, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1g.jags'
# savename='EelgrassM1f_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # , Sed = Sedtype, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2","eps","loglik")  

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC1g = WAIC
ModComp.1$WAIC[7] = WAIC1g$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1g <- LOOIC
ModComp.1$LOOIC[7] <- LOOIC1g[3]

# WAIC Detail
WAIC.1g <- data.frame(modID = c('WAIC1g'), model = c('1g'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1g <- data.frame(modID = c('LOOIC1g'), model = c('1g'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1g = out
```

#### Model 1h
Aboveground biomass ~ quad(time) + qaud(SOI)
```{r model 1h, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1h.jags'
# savename='EelgrassM1h_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # , Sed = Sedtype, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2","beta2b", "eps","loglik")  

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC1h = WAIC
ModComp.1$WAIC[8] = WAIC1h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1h <- LOOIC
ModComp.1$LOOIC[8] <- LOOIC1h[3]

# WAIC Detail
WAIC.1h <- data.frame(modID = c('WAIC1h'), model = c('1h'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1h <- data.frame(modID = c('LOOIC1h'), model = c('1h'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1h = out
```

### Model 1 Comparison
```{r Model 1 comparison, echo = FALSE}
# Clean up work session
stopCluster(cl = cl)
rm(out)

## WAIC ##
# Rank and organize model comparison table
modranks.WAIC <- order(ModComp.1$WAIC)
WAIC.1.full <- rbind(WAIC.1a, WAIC.1b, WAIC.1c, WAIC.1d, WAIC.1e, WAIC.1f, WAIC.1g, WAIC.1h)
comptab.WAIC <- compare(WAIC1a, WAIC1b, WAIC1c, WAIC1d, WAIC1e, WAIC1f, WAIC1g, WAIC1h)
filelist.WAIC <- row.names(comptab.WAIC)

for (i in 2:8){
  row = which(WAIC.1.full$modID == filelist.WAIC[i])
  comp = compare(eval(as.name(filelist.WAIC[i])) , eval(as.name(filelist.WAIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  WAIC.1.full$deltaWAIC[row] = comp[1]
  WAIC.1.full$deltaWAIC_se[row] = comp[2]
  WAIC.1.full$P_comp[row] = P_val
}

WAIC.1.full <- WAIC.1.full[modranks.WAIC,]
WAIC.1.full$P_comp[1] = 1
WAIC.1.full$Likelihood = exp(-0.5*WAIC.1.full$deltaWAIC)
WAIC.1.full$Likelihood[WAIC.1.full$P_comp < 0.1] = 0 
sumlik = sum(WAIC.1.full$Likelihood)
WAIC.1.full$WAICwt = WAIC.1.full$Likelihood/sumlik

# round
WAIC.1.full <- cbind(WAIC.1.full[,1:2], round(WAIC.1.full[, 3:9], 3))

## LOOIC ##
ModComp.1$LOOIC <- as.numeric(ModComp.1$LOOIC)
modranks.LOOIC <- order(ModComp.1$LOOIC)
LOOIC.1.full <- rbind(LOOIC.1a, LOOIC.1b, LOOIC.1c, LOOIC.1d, LOOIC.1e, LOOIC.1f, LOOIC.1g, LOOIC.1h)
comptab.LOOIC <- compare(LOOIC1a, LOOIC1b, LOOIC1c, LOOIC1d, LOOIC1e, LOOIC1f, LOOIC1g, LOOIC1h)
filelist.LOOIC <- row.names(comptab.LOOIC)

for (i in 2:8){
  row = which(LOOIC.1.full$modID == filelist.LOOIC[i])
  comp = compare(eval(as.name(filelist.LOOIC[i])) , eval(as.name(filelist.LOOIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  LOOIC.1.full$deltaLOOIC[row] = comp[1]
  LOOIC.1.full$deltaLOOIC_se[row] = comp[2]
}

LOOIC.1.full <- LOOIC.1.full[modranks.LOOIC,]
LOOIC.1.full$Likelihood = exp(-0.5*LOOIC.1.full$deltaLOOIC)
LOOIC.1.full$Likelihood[LOOIC.1.full$P_comp < 0.1] = 0 
sumlik = sum(LOOIC.1.full$Likelihood)
LOOIC.1.full$LOOICwt = LOOIC.1.full$Likelihood/sumlik

# round
LOOIC.1.full <- cbind(LOOIC.1.full[,1:2], round(LOOIC.1.full[, 3:8], 3))
```

### Model 1 Best model comparison tables
WAIC Comparison
```{r model 1 WAIC, echo = FALSE}
DT::datatable(WAIC.1.full)
```

LOICC comparison
```{r model 1 LOOIC, echo = FALSE}
DT::datatable(LOOIC.1.full)
```

### Model 1 Plotting best model
```{r model 1 plotting best model, echo=FALSE}
#eval(parse(text=paste0("out = out",modranks[1]))) 

# Extract MCMC values
post <- rbind(out1h$mcmc[[1]], out1h$mcmc[[2]])

# Loop over number of cores
for (i in 3:nc){
  post <- rbind(post, out1h$mcmc[[i]])
}

# Calculate summary stats
reps <- dim(post)[1]
sumout <- add.summary(out1h, c("sig","beta"))
sumstats <- sumout$summaries
vn <- row.names(sumstats)

# Diagnostic plots
plot(out1h, c('trace', 'histogram'), vars=c("sig","beta"))

# Create dataframes for plotting fixed effects: assume Model1h
mind <- min(Dayindx)
maxd <- max(Dayindx)
Julday <- numeric(length = length(seq(mind:maxd)))
Predict <- numeric(length = length(seq(mind:maxd)))
Lwr <- numeric(length = length(seq(mind:maxd)))
Upr <- numeric(length = length(seq(mind:maxd)))
sig <- post[,which(vn == 'sigO')]
bt0 <- post[,which(vn == 'beta0')]
bt1 <- post[,which(vn == 'beta1')]
bt1b <- post[,which(vn == 'beta1b')]
bt2 <- post[,which(vn == 'beta2')]
bt2b <- post[,which(vn == 'beta2b')]

for (d in mind:maxd){
  Julday[d] = d - 1 + Minday
  Mu = bt0 + bt1*d + bt1b*d^2
  Predict[d] = mean(exp(Mu + sig^2/2))
  Lwr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .975))
} 

dfDay = data.frame(Julianday = Julday, Mean = Predict, Lwr = Lwr, Upr = Upr)
dfData = data.frame(x = Julianday, y = Obs)

p1 <- ggplot(dfDay, aes(x = Julianday, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  # geom_point(data = dfData, aes(x=x, y=y))+
  xlab('Julian Day') + 
  ylab(bquote('Mean Pred aboveground mass' ~(g/m^2))) +
  theme(legend.position = "none")

Ottvals <- seq(min(Ottindx), max(Ottindx), length.out = 100)
Predict <- numeric(length = 100)
Lwr <- numeric(length = 100)
Upr <- numeric(length = 100)

for (o in 1:100){
  Mu <- bt0 + bt1*MeanDay + bt1b*MeanDay^2 + bt2*Ottvals[o] + bt2b*Ottvals[o]^2
  Predict[o] <- mean(exp(Mu + sig^2/2))
  Lwr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .975))
}

dfOtt = data.frame(OtterIndex = Ottvals, Mean = Predict, Lwr = Lwr, Upr = Upr)

p2 <- ggplot(dfOtt, aes(x = OtterIndex, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  xlab('Sea Otter Index') + 
  ylab(bquote('Mean Pred aboveground mass' ~(g/m^2))) +
  theme(legend.position = "none")

plot_grid(p1, p2, nrow = 2, ncol = 1)
```

### Model 2 - Belowground biomass
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, sediment type, and light attenuation may effect belowground biomass of eelgrass. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900.  

```{r Model 2 set up, echo=FALSE}
# Dependent observed variable: this should be whatever numeric variable you wish to analyze 
Obs <- as.numeric(tran.dat$bg_mass)

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Sedtype <- as.numeric(tran.dat$sed1_no)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Light <- as.numeric(tran.dat$light_attenu)[ii]
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting stuff?
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.2 <- data.frame(Model = c("Model_2a","Model_2b","Model_2c","Model_2d","Model_2e","Model_2f","Model_2g", "Model_2h"), 
                        WAIC = numeric(length = 8), 
                        LOOIC = numeric(length = 8))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 2a
Belowground biomass ~ time
```{r model 2a, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2a.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx) #, Ott = Ottindx, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2a <- WAIC
ModComp.2$WAIC[1] <- WAIC2a$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2a <- LOOIC
ModComp.2$LOOIC[1] <- LOOIC2a[3]

# WAIC Detail
WAIC.2a <- data.frame(modID = c('WAIC2a'), model = c('2a'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2a <- data.frame(modID = c('LOOIC2a'), model = c('2a'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2a <- out
```

#### Model 2b
Belowground biomass ~ time + SOI
```{r model 2b, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2b.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1", "beta2", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2b <- WAIC
ModComp.2$WAIC[2] <- WAIC2b$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2b <- LOOIC
ModComp.2$LOOIC[2] <- LOOIC2b[3]

# WAIC Detail
WAIC.2b <- data.frame(modID = c('WAIC2b'), model = c('2b'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2b <- data.frame(modID = c('LOOIC2b'), model = c('2b'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2b <- out
```

#### Model 2c 
Belowground biomass ~ time + SOI + Sediment
```{r model 2c, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2c.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2c <- WAIC
ModComp.2$WAIC[3] <- WAIC2c$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2c <- LOOIC
ModComp.2$LOOIC[3] <- LOOIC2c[3]

# WAIC Detail
WAIC.2c <- data.frame(modID = c('WAIC2c'), model = c('2c'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2c <- data.frame(modID = c('LOOIC2c'), model = c('2c'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2c <- out
```

#### Model 2d 
Belowground biomass ~ time + SOI + Sediment + Light
```{r model 2d, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2d.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Li = Light) #  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3", "beta4", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2d <- WAIC
ModComp.2$WAIC[4] <- WAIC2d$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2d <- LOOIC
ModComp.2$LOOIC[4] <- LOOIC2d[3]

# WAIC Detail
WAIC.2d <- data.frame(modID = c('WAIC2d'), model = c('2d'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2d <- data.frame(modID = c('LOOIC2d'), model = c('2d'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2d <- out
```

#### Model 2e 
Belowground biomass ~ time + quad(SOI)
```{r model 2e, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2e.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype, Li = Light) #  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2e <- WAIC
ModComp.2$WAIC[5] <- WAIC2e$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2e <- LOOIC
ModComp.2$LOOIC[5] <- LOOIC2e[3]

# WAIC Detail
WAIC.2e <- data.frame(modID = c('WAIC2e'), model = c('2e'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2e <- data.frame(modID = c('LOOIC2e'), model = c('2e'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2e <- out
```

#### Model 2f
Belowground biomass ~ time + quad(SOI) + sediment
```{r model 2f, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_2f.jags'
# savename='EelgrassM1f_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) # Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","beta3","eps","loglik") 

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC2f = WAIC
ModComp.2$WAIC[6] = WAIC2f$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2f <- LOOIC
ModComp.2$LOOIC[6] <- LOOIC2f[3]

# WAIC Detail
WAIC.2f <- data.frame(modID = c('WAIC2f'), model = c('2f'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2f <- data.frame(modID = c('LOOIC2f'), model = c('2f'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2f = out
```

#### Model 2g
Belowground biomass ~ quad(time) + SOI
```{r model 2g, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_2g.jags'
# savename='EelgrassM1f_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # , Sed = Sedtype, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2","eps","loglik")  

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC2g = WAIC
ModComp.2$WAIC[7] = WAIC2g$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2g <- LOOIC
ModComp.2$LOOIC[7] <- LOOIC2g[3]

# WAIC Detail
WAIC.2g <- data.frame(modID = c('WAIC2g'), model = c('2g'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2g <- data.frame(modID = c('LOOIC2g'), model = c('2g'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out2g = out
```

#### Model 2h
Belowground biomass ~ quad(time) + qaud(SOI)
```{r model 2h, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_2h.jags'
# savename='EelgrassM1h_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # , Sed = Sedtype, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2","beta2b", "eps","loglik")  

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC2h = WAIC
ModComp.2$WAIC[8] = WAIC2h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2h <- LOOIC
ModComp.2$LOOIC[8] <- LOOIC2h[3]

# WAIC Detail
WAIC.2h <- data.frame(modID = c('WAIC2h'), model = c('2h'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2h <- data.frame(modID = c('LOOIC2h'), model = c('2h'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2h = out
```

### Model 2 Comparison
```{r Model 2 comparison, echo = FALSE}
# Clean up work session
stopCluster(cl = cl)
rm(out)

## WAIC ##
# Rank and organize model comparison table
modranks.WAIC <- order(ModComp.2$WAIC)
WAIC.2.full <- rbind(WAIC.2a, WAIC.2b, WAIC.2c, WAIC.2d, WAIC.2e, WAIC.2f, WAIC.2g, WAIC.2h)
comptab.WAIC <- compare(WAIC2a, WAIC2b, WAIC2c, WAIC2d, WAIC2e, WAIC2f, WAIC2g, WAIC2h)
filelist.WAIC <- row.names(comptab.WAIC)

# Calculate comaprison values
for (i in 2:8){
  row = which(WAIC.2.full$modID == filelist.WAIC[i])
  comp = compare(eval(as.name(filelist.WAIC[i])) , eval(as.name(filelist.WAIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  WAIC.2.full$deltaWAIC[row] = comp[1]
  WAIC.2.full$deltaWAIC_se[row] = comp[2]
  WAIC.2.full$P_comp[row] = P_val
}

# organize final table
WAIC.2.full <- WAIC.2.full[modranks.WAIC,]
WAIC.2.full$P_comp[1] = 1
WAIC.2.full$Likelihood = exp(-0.5*WAIC.2.full$deltaWAIC)
WAIC.2.full$Likelihood[WAIC.2.full$P_comp < 0.1] = 0 
sumlik = sum(WAIC.2.full$Likelihood)
WAIC.2.full$WAICwt = WAIC.2.full$Likelihood/sumlik

# round
WAIC.2.full <- cbind(WAIC.2.full[,1:2], round(WAIC.2.full[, 3:8], 3))

## LOOIC ##
# Rank and organize model comparison table
ModComp.2$LOOIC <- as.numeric(ModComp.2$LOOIC)
modranks.LOOIC <- order(ModComp.2$LOOIC)
LOOIC.2.full <- rbind(LOOIC.2a, LOOIC.2b, LOOIC.2c, LOOIC.2d, LOOIC.2e, LOOIC.2f, LOOIC.2g, LOOIC.2h)
comptab.LOOIC <- compare(LOOIC2a, LOOIC2b, LOOIC2c, LOOIC2d, LOOIC2e, LOOIC2f, LOOIC2g, LOOIC2h)
filelist.LOOIC <- row.names(comptab.LOOIC)

# Calculate comparison values
for (i in 2:8){
  row = which(LOOIC.2.full$modID == filelist.LOOIC[i])
  comp = compare(eval(as.name(filelist.LOOIC[i])) , eval(as.name(filelist.LOOIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  LOOIC.2.full$deltaLOOIC[row] = comp[1]
  LOOIC.2.full$deltaLOOIC_se[row] = comp[2]
}

# organize final table
LOOIC.2.full <- LOOIC.2.full[modranks.LOOIC,]
LOOIC.2.full$Likelihood = exp(-0.5*LOOIC.2.full$deltaLOOIC)
LOOIC.2.full$Likelihood[LOOIC.2.full$P_comp < 0.1] = 0 
sumlik = sum(LOOIC.2.full$Likelihood)
LOOIC.2.full$LOOICwt = LOOIC.2.full$Likelihood/sumlik

# round
LOOIC.2.full <- cbind(LOOIC.2.full[,1:2], round(LOOIC.2.full[, 3:8], 3))
```

### Model 2 Comparison tables
WAIC Comparison
```{r model 2 WAIC, echo = FALSE}
DT::datatable(WAIC.2.full)
```

LOICC comparison
```{r model 2 LOOIC, echo = FALSE}
DT::datatable(LOOIC.2.full)
```

### Model 2 Plotting best model
If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model.
```{r model 2 plotting best model, echo=FALSE}
# Extract best model
best2.WAIC <- paste0(c("out", paste0(WAIC.2.full[1,2])), collapse = "")
best2.LOOIC <- paste0(c("out", paste0(LOOIC.2.full[1,2])), collapse = "")

# Test for difference in best model between WAIC and LOOIC. If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model
ifelse(all.equal(best2.WAIC, best2.LOOIC) == TRUE, best2 <- eval(best2.WAIC), best2 <- eval(best2.LOOIC))

# Extract MCMC values
post <- rbind(out2a$mcmc[[1]], out2a$mcmc[[2]])

# Loop over number of cores
for (i in 3:nc){
  post <- rbind(post, out2a$mcmc[[i]])
}

# Calculate summary stats
reps <- dim(post)[1]
sumout <- add.summary(out2a, c("sig","beta"))
sumstats <- sumout$summaries
vn <- row.names(sumstats)

# Diagnostic plots
plot(out2a, c('trace', 'histogram'), vars=c("sig","beta"))

# Create dataframes for plotting fixed effects: assume Model2a
mind <- min(Dayindx)
maxd <- max(Dayindx)
Julday <- numeric(length = length(seq(mind:maxd)))
Predict <- numeric(length = length(seq(mind:maxd)))
Lwr <- numeric(length = length(seq(mind:maxd)))
Upr <- numeric(length = length(seq(mind:maxd)))
sig <- post[,which(vn == 'sigO')]
bt0 <- post[,which(vn == 'beta0')]
bt1 <- post[,which(vn == 'beta1')]

for (d in mind:maxd){
  Julday[d] = d - 1 + Minday
  Mu = bt0 + bt1*d
  Predict[d] = mean(exp(Mu + sig^2/2))
  Lwr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .975))
} 

dfDay = data.frame(Julianday = Julday, Mean = Predict, Lwr = Lwr, Upr = Upr)
dfData = data.frame(x = Julianday, y = Obs)

p1 <- ggplot(dfDay, aes(x = Julianday, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  # geom_point(data = dfData, aes(x=x, y=y))+
  xlab('Julian Day') + 
  ylab(bquote('Mean Pred belowground mass' ~(g/m^2))) +
  theme(legend.position = "none")

print(p1)
```

### Model 3 - Shoot Density
Responce is negative binomially distributed count data. We hypothesise that time (as julian day), sea otter index, sediment type, and light attenuation may effect belowground biomass of eelgrass.

```{r model 3 set up, echo = FALSE}
# Dependent observed variable: eeglrass shoot density per meter sq
Obs <- as.numeric(tran.dat$eelgrass_shoots_msq)

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Sedtype <- as.numeric(tran.dat$sed1_no)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Light <- as.numeric(tran.dat$light_attenu)[ii]
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting data attributes
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.3 <- data.frame(Model = c("Model_3a","Model_3b","Model_3c","Model_3d","Model_3e","Model_3f","Model_3g", "Model_3h", "Model_3i"), WAIC = numeric(length = 9), LOOIC = numeric(length = 9))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 3a
Shoot density ~ time
```{r model 3a, echo = FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3a.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx) # Ott = Ottindx, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0","beta1","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3a <- WAIC
ModComp.3$WAIC[1] <- WAIC3a$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3a <- LOOIC
ModComp.3$LOOIC[1] <- LOOIC3a[3]

# WAIC Detail
WAIC.3a <- data.frame(modID = c('WAIC3a'), model = c('3a'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3a <- data.frame(modID = c('LOOIC3a'), model = c('3a'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3a <- out
```

#### Model 3b
Shoot density ~ time + SOI
```{r model 3b, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3b.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, , Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers","beta0","beta1","beta2", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3b <- WAIC
ModComp.3$WAIC[2] <- WAIC3b$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3b <- LOOIC
ModComp.3$LOOIC[2] <- LOOIC3b[3]

# WAIC Detail
WAIC.3b <- data.frame(modID = c('WAIC3b'), model = c('3b'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3b <- data.frame(modID = c('LOOIC3b'), model = c('3b'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3b <- out
```

#### Model 3c
Shoot density ~ time + SOI + Sediment
```{r model 3c, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3c.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #, ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers","beta0","beta1","beta2", "beta3", "eps","loglik")  

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3c <- WAIC
ModComp.3$WAIC[3] <- WAIC3c$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3c <- LOOIC
ModComp.3$LOOIC[3] <- LOOIC3c[3]

# WAIC Detail
WAIC.3c <- data.frame(modID = c('WAIC3c'), model = c('3c'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3c <- data.frame(modID = c('LOOIC3c'), model = c('3c'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3c <- out
```

#### Model 3d
Shoot density ~ time + SOI + Sediment + Light
```{r model 3d, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3d.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Li = Light) #, ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta2", "beta3", "beta4", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3d <- WAIC
ModComp.3$WAIC[4] <- WAIC3d$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3d <- LOOIC
ModComp.3$LOOIC[4] <- LOOIC3d[3]

# WAIC Detail
WAIC.3d <- data.frame(modID = c('WAIC3d'), model = c('3d'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3d <- data.frame(modID = c('LOOIC3d'), model = c('3d'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3d <- out
```

#### Model 3e
Shoot density ~ time + quad(SOI)
```{r model 3e, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3e.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype, Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta2", "beta2b", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3e <- WAIC
ModComp.3$WAIC[5] <- WAIC3e$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3e <- LOOIC
ModComp.3$LOOIC[5] <- LOOIC3e[3]

# WAIC Detail
WAIC.3e <- data.frame(modID = c('WAIC3e'), model = c('3e'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3e <- data.frame(modID = c('LOOIC3e'), model = c('3e'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3e <- out
```

#### Model 3f
Shoot density ~ time + quad(SOI) + sediment
```{r model 3f, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3f.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) # , Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta2", "beta2b", "beta3", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3f <- WAIC
ModComp.3$WAIC[6] <- WAIC3f$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3f <- LOOIC
ModComp.3$LOOIC[6] <- LOOIC3f[3]

# WAIC Detail
WAIC.3f <- data.frame(modID = c('WAIC3f'), model = c('3f'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3f <- data.frame(modID = c('LOOIC3f'), model = c('3f'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3f <- out
```

#### Model 3g
Shoot density ~ quad(time) + SOI
```{r model 3g, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3g.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # Sed = Sedtype Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta1b", "beta2", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3g <- WAIC
ModComp.3$WAIC[7] <- WAIC3g$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3g <- LOOIC
ModComp.3$LOOIC[7] <- LOOIC3g[3]

# WAIC Detail
WAIC.3g <- data.frame(modID = c('WAIC3g'), model = c('3g'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3g <- data.frame(modID = c('LOOIC3g'), model = c('3g'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3g <- out
```

#### Model 3h
Shoot density ~ quad(time) + quad(SOI)
```{r model 3h, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3h.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # Sed = Sedtype Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta1b", "beta2", "beta2b", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3h <- WAIC
ModComp.3$WAIC[8] <- WAIC3h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3h <- LOOIC
ModComp.3$LOOIC[8] <- LOOIC3h[3]

# WAIC Detail
WAIC.3h <- data.frame(modID = c('WAIC3h'), model = c('3h'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3h <- data.frame(modID = c('LOOIC3h'), model = c('3h'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3h <- out
```

#### Model 3i
Shoot density ~ quad(SOI)
```{r model 3i, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3i.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Ott = Ottindx) # Sed = Sedtype Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta2", "beta2b", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3i <- WAIC
ModComp.3$WAIC[9] <- WAIC3h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3i <- LOOIC
ModComp.3$LOOIC[9] <- LOOIC3h[3]

# WAIC Detail
WAIC.3i <- data.frame(modID = c('WAIC3i'), model = c('3i'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3i <- data.frame(modID = c('LOOIC3i'), model = c('3i'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3i <- out
```

### Model 3 Comparison
```{r Model 3 comparison, echo = FALSE}
# Clean up work session
stopCluster(cl = cl)
rm(out)

## WAIC ##
# Rank and organize model comparison table
modranks.WAIC <- order(ModComp.3$WAIC)
WAIC.3.full <- rbind(WAIC.3a, WAIC.3b, WAIC.3c, WAIC.3d, WAIC.3e, WAIC.3f, WAIC.3g, WAIC.3h, WAIC.3i)
comptab.WAIC <- compare(WAIC3a, WAIC3b, WAIC3c, WAIC3d, WAIC3e, WAIC3f, WAIC3g, WAIC3h, WAIC3i)
filelist.WAIC <- row.names(comptab.WAIC)

# Calculate comaprison values
for (i in 2:9){
  row = which(WAIC.3.full$modID == filelist.WAIC[i])
  comp = compare(eval(as.name(filelist.WAIC[i])) , eval(as.name(filelist.WAIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  WAIC.3.full$deltaWAIC[row] = comp[1]
  WAIC.3.full$deltaWAIC_se[row] = comp[2]
  WAIC.3.full$P_comp[row] = P_val
}

# organize final table
WAIC.3.full <- WAIC.3.full[modranks.WAIC,]
WAIC.3.full$P_comp[1] = 1
WAIC.3.full$Likelihood = exp(-0.5*WAIC.3.full$deltaWAIC)
WAIC.3.full$Likelihood[WAIC.3.full$P_comp < 0.1] = 0 
sumlik = sum(WAIC.3.full$Likelihood)
WAIC.3.full$WAICwt = WAIC.3.full$Likelihood/sumlik

# round
WAIC.3.full <- cbind(WAIC.3.full[,1:2], round(WAIC.3.full[, 3:8], 3))

## LOOIC ##
# Rank and organize model comparison table
ModComp.3$LOOIC <- as.numeric(ModComp.3$LOOIC)
modranks.LOOIC <- order(ModComp.3$LOOIC)
LOOIC.3.full <- rbind(LOOIC.3a, LOOIC.3b, LOOIC.3c, LOOIC.3d, LOOIC.3e, LOOIC.3f, LOOIC.3g, LOOIC.3h, LOOIC.3i)
comptab.LOOIC <- compare(LOOIC3a, LOOIC3b, LOOIC3c, LOOIC3d, LOOIC3e, LOOIC3f, LOOIC3g, LOOIC3h, LOOIC3i)
filelist.LOOIC <- row.names(comptab.LOOIC)

# Calculate comparison values
for (i in 2:9){
  row = which(LOOIC.3.full$modID == filelist.LOOIC[i])
  comp = compare(eval(as.name(filelist.LOOIC[i])) , eval(as.name(filelist.LOOIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  LOOIC.3.full$deltaLOOIC[row] = comp[1]
  LOOIC.3.full$deltaLOOIC_se[row] = comp[2]
}

# organize final table
LOOIC.3.full <- LOOIC.3.full[modranks.LOOIC,]
LOOIC.3.full$Likelihood = exp(-0.5*LOOIC.3.full$deltaLOOIC)
LOOIC.3.full$Likelihood[LOOIC.3.full$P_comp < 0.1] = 0 
sumlik = sum(LOOIC.3.full$Likelihood)
LOOIC.3.full$LOOICwt = LOOIC.3.full$Likelihood/sumlik

# round
LOOIC.3.full <- cbind(LOOIC.3.full[,1:2], round(LOOIC.3.full[, 3:8], 3))
```

### Model 3 Comparison tables
WAIC Comparison
```{r model 3 WAIC, echo = FALSE}
DT::datatable(WAIC.3.full)
```

LOICC comparison
```{r model 3 LOOIC, echo = FALSE}
DT::datatable(LOOIC.3.full)
```

### Model 3 Plotting best model
THIS IS NOT OPERATIONAL If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model.
```{r model 3 plotting best model, echo=FALSE}
# Extract best model
best3.WAIC <- paste0(c("out", paste0(WAIC.3.full[1,2])), collapse = "")
best3.LOOIC <- paste0(c("out", paste0(LOOIC.3.full[1,2])), collapse = "")

# Test for difference in best model between WAIC and LOOIC. If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model
ifelse(all.equal(best3.WAIC, best3.LOOIC) == TRUE, best2 <- eval(best3.WAIC), best2 <- eval(best3.LOOIC))

# Extract MCMC values
post <- rbind(out3a$mcmc[[1]], out3a$mcmc[[2]])

# Loop over number of cores
for (i in 3:nc){
  post <- rbind(post, out3a$mcmc[[i]])
}

# Calculate summary stats
reps <- dim(post)[1]
sumout <- add.summary(out3a, c("sig","beta", "Dispers"))
sumstats <- sumout$summaries
vn <- row.names(sumstats)

# Diagnostic plots
plot(out3a, c('trace', 'histogram'), vars=c("sig","Dispers","beta"))

# Create dataframes for plotting fixed effects
mind <- min(Dayindx)
maxd <- max(Dayindx)
Julday <- numeric(length = length(seq(mind:maxd)))
Predict <- numeric(length = length(seq(mind:maxd)))
Lwr <- numeric(length = length(seq(mind:maxd)))
Upr <- numeric(length = length(seq(mind:maxd)))
sig <- post[,which(vn == 'sigS')]
dis <- post[,which(vn == 'Dispers')]
bt0 <- post[,which(vn == 'beta0')]
bt1 <- post[,which(vn == 'beta1')]

for (d in mind:maxd){
  Julday[d] = d - 1 + Minday
  ldayMu = bt0 + bt1*d
  Predict[d] = mean(exp(Mu + sig^2/2))
  Lwr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .975))
} 

dfDay = data.frame(Julianday = Julday, Mean = Predict, Lwr = Lwr, Upr = Upr)
dfData = data.frame(x = Julianday, y = Obs)

p1 <- ggplot(dfDay, aes(x = Julianday, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  # geom_point(data = dfData, aes(x=x, y=y))+
  xlab('Julian Day') + 
  ylab(bquote('Mean Pred belowground mass' ~(g/m^2))) +
  theme(legend.position = "none")

print(p1)

Ottvals <- seq(min(Ottindx), max(Ottindx), length.out = 100)
Predict <- numeric(length = 100)
Lwr <- numeric(length = 100)
Upr <- numeric(length = 100)

for (o in 1:100){
  Mu <- bt0 + bt1*MeanDay + bt2*Ottvals[o] + bt2b*Ottvals[o]^2
  Predict[o] <- mean(exp(Mu + sig^2/2))
  Lwr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .975))
}

dfOtt = data.frame(OtterIndex = Ottvals, Mean = Predict, Lwr = Lwr, Upr = Upr)

p2 <- ggplot(dfOtt, aes(x = OtterIndex, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  xlab('Sea Otter Index') + 
  ylab(bquote('Mean Pred aboveground mass' ~(g/m^2))) +
  theme(legend.position = "none")

plot_grid(p1, p2, nrow = 2, ncol = 1)
```

### Model 4 - Aboveground to belowground biomass.
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, sediment type, and light attenuation may effect belowground biomass of eelgrass. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900.

```{r Model 4 set up, echo=FALSE}
# Dependent observed variable: this should be whatever numeric variable you wish to analyze 
Obs <- as.numeric(tran.dat$agbg_mass)

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Sedtype <- as.numeric(tran.dat$sed1_no)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Light <- as.numeric(tran.dat$light_attenu)[ii]
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting attributes of data
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.4 <- data.frame(Model = c("Model_4a","Model_4b","Model_4c","Model_4d","Model_4e","Model_4f","Model_4g", "Model_4h"), WAIC = numeric(length = 8), LOOIC = numeric(length = 8))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 4a
AG/BG ~ time
```{r model 4a, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4a.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx) #, Ott = Ottindx, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4a <- WAIC
ModComp.4$WAIC[1] <- WAIC4a$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4a <- LOOIC
ModComp.4$LOOIC[1] <- LOOIC4a[3]

# WAIC Detail
WAIC.4a <- data.frame(modID = c('WAIC4a'), model = c('4a'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4a <- data.frame(modID = c('LOOIC4a'), model = c('4a'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4a <- out
```

#### Model 4b
AG/BG ~ time + SOI
```{r model 4b, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4b.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4b <- WAIC
ModComp.4$WAIC[2] <- WAIC4b$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4b <- LOOIC
ModComp.4$LOOIC[2] <- LOOIC4b[3]

# WAIC Detail
WAIC.4b <- data.frame(modID = c('WAIC4b'), model = c('4b'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4b <- data.frame(modID = c('LOOIC4b'), model = c('4b'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4b <- out
```

#### Model 4c
AG/BG ~ time + SOI + sediment
```{r model 4c, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4c.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4c <- WAIC
ModComp.4$WAIC[3] <- WAIC4c$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4c <- LOOIC
ModComp.4$LOOIC[3] <- LOOIC4c[3]

# WAIC Detail
WAIC.4c <- data.frame(modID = c('WAIC4c'), model = c('4c'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4c <- data.frame(modID = c('LOOIC4c'), model = c('4c'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4c <- out
```

#### Model 4d
AG/BG ~ time + SOI + sediment + light
```{r model 4d, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4d.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Li = Light) #,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3","beta4", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4d <- WAIC
ModComp.4$WAIC[4] <- WAIC4d$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4d <- LOOIC
ModComp.4$LOOIC[4] <- LOOIC4d[3]

# WAIC Detail
WAIC.4d <- data.frame(modID = c('WAIC4d'), model = c('4d'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4d <- data.frame(modID = c('LOOIC4d'), model = c('4d'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4d <- out
```

#### Model 4e
AG/BG ~ time + quad(SOI)
```{r model 4e, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4e.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype, Li = Light Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4e <- WAIC
ModComp.4$WAIC[5] <- WAIC4e$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4e <- LOOIC
ModComp.4$LOOIC[5] <- LOOIC4e[3]

# WAIC Detail
WAIC.4e <- data.frame(modID = c('WAIC4e'), model = c('4e'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4e <- data.frame(modID = c('LOOIC4e'), model = c('4e'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4e <- out
```

#### Model 4f
AG/BG ~ time + quad(SOI) + Sediment
```{r model 4f, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4f.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #, Li = Light Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b", "beta3",  "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4f <- WAIC
ModComp.4$WAIC[6] <- WAIC4f$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4f <- LOOIC
ModComp.4$LOOIC[6] <- LOOIC4f[3]

# WAIC Detail
WAIC.4f <- data.frame(modID = c('WAIC4f'), model = c('4f'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4f <- data.frame(modID = c('LOOIC4f'), model = c('4f'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4f <- out
```

#### Model 4g
AG/BG ~ quad(time) + SOI
```{r model 4g, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4g.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Li = Light Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4g <- WAIC
ModComp.4$WAIC[7] <- WAIC4g$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4g <- LOOIC
ModComp.4$LOOIC[7] <- LOOIC4g[3]

# WAIC Detail
WAIC.4g <- data.frame(modID = c('WAIC4g'), model = c('4g'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4g <- data.frame(modID = c('LOOIC4g'), model = c('4g'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4g <- out
```

#### Model 4h
AG/BG ~ quad(time) + quad(SOI)
```{r model 4h, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4h.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Li = Light Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2", "beta2b",  "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4h <- WAIC
ModComp.4$WAIC[8] <- WAIC4h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4h <- LOOIC
ModComp.4$LOOIC[8] <- LOOIC4h[3]

# WAIC Detail
WAIC.4h <- data.frame(modID = c('WAIC4h'), model = c('4h'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4h <- data.frame(modID = c('LOOIC4h'), model = c('4h'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4h <- out
```

### Model 4 Comparison
```{r Model 4 comparison, echo = FALSE}
# Clean up work session
stopCluster(cl = cl)
rm(out)

## WAIC ##
# Rank and organize model comparison table
modranks.WAIC <- order(ModComp.4$WAIC)
WAIC.4.full <- rbind(WAIC.4a, WAIC.4b, WAIC.4c, WAIC.4d, WAIC.4e, WAIC.4f, WAIC.4g, WAIC.4h)
comptab.WAIC <- compare(WAIC4a, WAIC4b, WAIC4c, WAIC4d, WAIC4e, WAIC4f, WAIC4g, WAIC4h)
filelist.WAIC <- row.names(comptab.WAIC)

# Calculate comaprison values
for (i in 2:8){
  row = which(WAIC.4.full$modID == filelist.WAIC[i])
  comp = compare(eval(as.name(filelist.WAIC[i])) , eval(as.name(filelist.WAIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  WAIC.4.full$deltaWAIC[row] = comp[1]
  WAIC.4.full$deltaWAIC_se[row] = comp[2]
  WAIC.4.full$P_comp[row] = P_val
}

# organize final table
WAIC.4.full <- WAIC.4.full[modranks.WAIC,]
WAIC.4.full$P_comp[1] = 1
WAIC.4.full$Likelihood = exp(-0.5*WAIC.4.full$deltaWAIC)
WAIC.4.full$Likelihood[WAIC.4.full$P_comp < 0.1] = 0 
sumlik = sum(WAIC.4.full$Likelihood)
WAIC.4.full$WAICwt = WAIC.4.full$Likelihood/sumlik

# round
WAIC.4.full <- cbind(WAIC.4.full[,1:2], round(WAIC.4.full[, 3:9], 3))

## LOOIC ##
# Rank and organize model comparison table
ModComp.4$LOOIC <- as.numeric(ModComp.4$LOOIC)
modranks.LOOIC <- order(ModComp.4$LOOIC)
LOOIC.4.full <- rbind(LOOIC.4a, LOOIC.4b, LOOIC.4c, LOOIC.4d, LOOIC.4e, LOOIC.4f, LOOIC.4g, LOOIC.4h)
comptab.LOOIC <- compare(LOOIC4a, LOOIC4b, LOOIC4c, LOOIC4d, LOOIC4e, LOOIC4f, LOOIC4g, LOOIC4h)
filelist.LOOIC <- row.names(comptab.LOOIC)

# Calculate comparison values
for (i in 2:8){
  row = which(LOOIC.4.full$modID == filelist.LOOIC[i])
  comp = compare(eval(as.name(filelist.LOOIC[i])) , eval(as.name(filelist.LOOIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  LOOIC.4.full$deltaLOOIC[row] = comp[1]
  LOOIC.4.full$deltaLOOIC_se[row] = comp[2]
}

# organize final table
LOOIC.4.full <- LOOIC.4.full[modranks.LOOIC,]
LOOIC.4.full$Likelihood = exp(-0.5*LOOIC.4.full$deltaLOOIC)
LOOIC.4.full$Likelihood[LOOIC.4.full$P_comp < 0.1] = 0 
sumlik = sum(LOOIC.4.full$Likelihood)
LOOIC.4.full$LOOICwt = LOOIC.4.full$Likelihood/sumlik

# round
LOOIC.4.full <- cbind(LOOIC.4.full[,1:2], round(LOOIC.4.full[, 3:8], 3))
```

### Model 4 Comparison tables
WAIC Comparison
```{r model 4 WAIC, echo = FALSE}
DT::datatable(WAIC.4.full)
```

LOICC comparison
```{r model 4 LOOIC, echo = FALSE}
DT::datatable(LOOIC.4.full)
```

### Model 4 Plotting best model
```{r model 4 plotting best model, echo=FALSE}
# Extract best model
best4.WAIC <- paste0(c("out", paste0(WAIC.4.full[1,2])), collapse = "")
best4.LOOIC <- paste0(c("out", paste0(LOOIC.4.full[1,2])), collapse = "")

# Test for difference in best model between WAIC and LOOIC. If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model
ifelse(all.equal(best4.WAIC, best4.LOOIC) == TRUE, best2 <- eval(best4.WAIC), best2 <- eval(best4.LOOIC))

# Extract MCMC values
post <- rbind(out4b$mcmc[[1]], out4b$mcmc[[2]])

# Loop over number of cores
for (i in 3:nc){
  post <- rbind(post, out4b$mcmc[[i]])
}

# Calculate summary stats
reps <- dim(post)[1]
sumout <- add.summary(out4b, c("sig","beta"))
sumstats <- sumout$summaries
vn <- row.names(sumstats)

# Diagnostic plots
plot(out4b, c('trace', 'histogram'), vars=c("sig","beta"))

# Create dataframes for plotting fixed effects: assume Model4b
mind <- min(Dayindx)
maxd <- max(Dayindx)
Julday <- numeric(length = length(seq(mind:maxd)))
Predict <- numeric(length = length(seq(mind:maxd)))
Lwr <- numeric(length = length(seq(mind:maxd)))
Upr <- numeric(length = length(seq(mind:maxd)))
sig <- post[,which(vn == 'sigO')]
bt0 <- post[,which(vn == 'beta0')]
bt1 <- post[,which(vn == 'beta1')]
bt2 <- post[,which(vn == 'beta2')]

for (d in mind:maxd){
  Julday[d] = d - 1 + Minday
  Mu = bt0 + bt1*d
  Predict[d] = mean(exp(Mu + sig^2/2))
  Lwr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .975))
} 

dfDay = data.frame(Julianday = Julday, Mean = Predict, Lwr = Lwr, Upr = Upr)
dfData = data.frame(x = Julianday, y = Obs)

p1 <- ggplot(dfDay, aes(x = Julianday, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  # geom_point(data = dfData, aes(x=x, y=y))+
  xlab('Julian Day') + 
  ylab(bquote('Mean Pred AG/BG mass' ~(g/m^2))) +
  theme(legend.position = "none")

Ottvals <- seq(min(Ottindx), max(Ottindx), length.out = 100)
Predict <- numeric(length = 100)
Lwr <- numeric(length = 100)
Upr <- numeric(length = 100)

for (o in 1:100){
  Mu <- bt0 + bt1*MeanDay  + bt2*Ottvals[o]
  Predict[o] <- mean(exp(Mu + sig^2/2))
  Lwr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .975))
}

dfOtt = data.frame(OtterIndex = Ottvals, Mean = Predict, Lwr = Lwr, Upr = Upr)

p2 <- ggplot(dfOtt, aes(x = OtterIndex, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  xlab('Sea Otter Index') + 
  ylab(bquote('Mean Pred AG/BG mass' ~(g/m^2))) +
  theme(legend.position = "none")

plot_grid(p1, p2, nrow = 2, ncol = 1)
```
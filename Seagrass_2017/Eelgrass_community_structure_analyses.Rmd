---
title: "Eelgrass_community_structure_analyses"
author: "Wendel Raymond"
date: "January 16, 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r libraries, echo = FALSE, message = FALSE, warning = FALSE}
library(ggplot2)
library(dplyr)
library(lattice)
library(coda)
library(boot)
library(parallel)
library(rjags)
library(runjags)
library(loo)
library(HDInterval)
library(DT)
library(cowplot)
library(arm)

theme_set(theme_classic())
```


# Analyses for testing hypotheses related to eelgrass community structure
**Question** 
What is the structure of eelgrass communities across a gradient of sea otter impacts?

**Overall Hypothesis**
If top-down (sea otter) forces are structuring eelgrass communities, then we would expect alternating relative abundance from trophic level to trophic level.

## Outline
1. Description of data
2. Testing assumptions
    + normality
    + co-linearity
3. Models

## 1. Data
**Response metrics**
1. eelgrass aboveground biomass density (g / m^2^)
2. eelgrass belowground biomass density (g / m^2^)
3. eelgrass shoot density (count / m^2^)
4. ratio of aboveground to belowground biomass density (g / m^2^)
5. epiphyte load (g epiphyte / g eelgrass)
6. total grazer load (g grazers/ g eelgrass)
    + gastropod load (g grazers/ g eelgrass)
    + crustaecean load (g grazers/ g eelgrass)
7. crab biomass (g) - can also be counts
8. fish biomass (g) - can also be counts

**Primary explanatory factors**
Not all these fators will necessarily be used in all models
1. Time
2. Sediment type (primary sediment type from the "inside" eelgrass transect)
3. Percent light

**Secondary explanatory factors**
Factors that are more specific to certain tests
1. crab biomass (g)
2. fish biomass (g)
3. grazer biomass (g)

```{r import data, echo = FALSE, message = FALSE, warning = FALSE}
tran.dat <- read.csv( "../ALL_DATA/eelgrass_bio_sed_transect_derived.csv", header = TRUE, stringsAsFactors = FALSE)

crab.dat <- read.csv("../All_DATA/eelgrass_crab_pot_derived.csv", header = TRUE, stringsAsFactors = FALSE)
crab.dat$string <- as.character(crab.dat$string)

fish.dat <- read.csv("../ALL_DATA/eelgrass_beach_seine_derived.csv", header = TRUE, stringsAsFactors = FALSE)
```

### Data Prep
Crab data preparation. This needs to be done to summarise by site and string (i.e. loose species information).
```{r crab sites string, echo=FALSE}
crab.string <- crab.dat %>% 
  group_by(site, string) %>% 
  summarise(count = sum(count),
            mass = sum(mass_g))
```

Crab data preparation. Summarize counts and mass of cancer/rock crabs.
```{r rock crabs string, echo=FALSE}
crab.rock <- crab.dat %>% 
  filter(sp_code == "CRABDUN" | sp_code == "CRABRR" | sp_code == "CRAGRA"| sp_code == "UNRKCB") %>% 
  group_by(site, string) %>% 
  summarise(count = sum(count),
            mass = sum(mass_g))
```

## 2. Testing assumptions

### Normality
Response metrics should have approximatley normal distribution. For this exploration we can omit the NA rows that allowed for merging with sediment data. We will also omit the April sites (L01 and H01). Resulting data frame should have 19 X 9 rows = 152. For the crab data we also want to omit the April sites. Initially we will also want to sum crab biomass within each string (pool over species). The imported data is not set up this way so the data will we summarised as such. The imported crab data is fairly bare, in that it only has the site name, date, and soak time. Data will need to be merged with sea otter index, and other things for formal analysis.
```{r data edit}
#tran.dat <- tran.dat %>% 
  #filter(site != "2017_L_01" & site != "2017_H_01") %>% 
  #filter(quadrat < 9)

#crab <- crab.dat %>% 
  #filter(site != "2017_L_01" & site != "2017_H_01") %>% 
  #group_by(site, string) %>% 
  #summarise(mass_g = sum(mass_g))

#crab.dat <- merge(unique(crab.dat[, 1:8]), crab, by = "site", all.y = TRUE)
```

Eelgrass shoot density appears reasonably normal but fails SW test. Further test indicate that sqrt transformation achives normality.
```{r shoot dens normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(eelgrass_shoots_msq)) +
  geom_histogram(bins = 10) +
  labs(x = "Eelgrass shoot density", y = "Counts")

qqnorm(tran.dat$eelgrass_shoots_msq)
qqline(tran.dat$eelgrass_shoots_msq, lwd = 2)

shapiro.test(tran.dat$eelgrass_shoots_msq)

## ln transformation ##
ggplot(tran.dat, aes(log(eelgrass_shoots_msq))) +
  geom_histogram(bins = 10) +
  labs(x = "log Eelgrass shoot density", y = "Counts")

qqnorm(log(tran.dat$eelgrass_shoots_msq))
qqline(log(tran.dat$eelgrass_shoots_msq), lwd = 2)

shapiro.test(log(tran.dat$eelgrass_shoots_msq))

## sqrt transfrormation ##
ggplot(tran.dat, aes(sqrt(eelgrass_shoots_msq))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt Eelgrass shoot density", y = "Counts")

qqnorm(sqrt(tran.dat$eelgrass_shoots_msq))
qqline(sqrt(tran.dat$eelgrass_shoots_msq), lwd = 2)

shapiro.test(sqrt(tran.dat$eelgrass_shoots_msq))
```

Aboveground biomass shows some right skewness suggesting ln transformation. Log transformation was not super great. However square roor transformation appears more helpful. SW tests all indicate at least some non-normality, but sqrt transformation is the best.
```{r ag normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(ag_mass)) +
  geom_histogram(bins = 10) +
  labs(x = "Aboveground biomass", y = "Counts")

qqnorm(tran.dat$ag_mass)
qqline(tran.dat$ag_mass, lwd = 2)

shapiro.test(tran.dat$ag_mass)

## ln transformed ##
ggplot(tran.dat, aes(log(ag_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "log Aboveground biomass", y = "Counts")

qqnorm(log(tran.dat$ag_mass))
qqline(log(tran.dat$ag_mass), lwd = 2)

shapiro.test(log(tran.dat$ag_mass))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(ag_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt Aboveground biomass", y = "Counts")

qqnorm(sqrt(tran.dat$ag_mass))
qqline(sqrt(tran.dat$ag_mass), lwd = 2)

shapiro.test(sqrt(tran.dat$ag_mass))
```

Belowground biomass also shows right skewness. Both log and square root tranformations improve normality. SW test indicates that log transformation achieves normality.
```{r bg normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(bg_mass)) +
  geom_histogram(bins = 10) +
  labs(x = "Belowground biomass", y = "Counts")

qqnorm(tran.dat$bg_mass)
qqline(tran.dat$bg_mass, lwd = 2)

shapiro.test(tran.dat$bg_mass)

## ln transformed ##
ggplot(tran.dat, aes(log(bg_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "log Belowground biomass", y = "Counts")

qqnorm(log(tran.dat$bg_mass))
qqline(log(tran.dat$bg_mass), lwd = 2)

shapiro.test(log(tran.dat$bg_mass))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(bg_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt belowground biomass", y = "Counts")

qqnorm(sqrt(tran.dat$bg_mass))
qqline(sqrt(tran.dat$bg_mass), lwd = 2)

shapiro.test(sqrt(tran.dat$bg_mass))
```

Ratio of above to belowground biomass also appears right skewed. SW test indicates that log transformation is best.
```{r agbg normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(ag_mass / bg_mass)) +
  geom_histogram(bins = 10) +
  labs(x = "AG:BG biomass", y = "Counts")

qqnorm(tran.dat$ag_mass / tran.dat$bg_mass)
qqline(tran.dat$ag_mass / tran.dat$bg_mass, lwd = 2)

## ln transformed ##
ggplot(tran.dat, aes(log(ag_mass / bg_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "log AG:BG biomass", y = "Counts")

qqnorm(log(tran.dat$ag_mass / tran.dat$bg_mass))
qqline(log(tran.dat$ag_mass / tran.dat$bg_mass), lwd = 2)

shapiro.test(log(tran.dat$ag_mass / tran.dat$bg_mass))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(ag_mass / bg_mass))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt AG:BG biomass", y = "Counts")

qqnorm(sqrt(tran.dat$ag_mass / tran.dat$bg_mass))
qqline(sqrt(tran.dat$ag_mass / tran.dat$bg_mass), lwd = 2)

shapiro.test(sqrt(tran.dat$ag_mass / tran.dat$bg_mass))
```

Epiphyte load. This one is a bit tricky, any sort of tranformation does not deal with the outliers well. 
```{r epi load normality, echo=FALSE}
## Raw data ##
ggplot(tran.dat, aes(epimass_shootmass)) +
  geom_histogram(bins = 50) +
  labs(x = "Epiphyte load", y = "Counts")

qqnorm(tran.dat$epimass_shootmass)
qqline(tran.dat$epimass_shootmass, lwd = 2)

## ln transformed ##
ggplot(tran.dat, aes(log(epimass_shootmass + 0.1))) +
  geom_histogram(bins = 10) +
  labs(x = "log Epiphyte load", y = "Counts")

qqnorm(log(tran.dat$epimass_shootmass + 0.1))
qqline(log(tran.dat$epimass_shootmass + 0.1), lwd = 2)

shapiro.test(log(tran.dat$epimass_shootmass + 0.1))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(epimass_shootmass))) +
  geom_histogram(bins = 10) +
  labs(x = "sqrt Epiphyte load", y = "Counts")

qqnorm(sqrt(tran.dat$epimass_shootmass))
qqline(sqrt(tran.dat$epimass_shootmass), lwd = 2)

shapiro.test(sqrt(tran.dat$epimass_shootmass))
```

Grazer load does not respond well to any transformation. Given the distribution of the raw data it may be best to keep it the way it is.
```{r grazer load normality, echo=FALSE}
## raw data ##
ggplot(tran.dat, aes(grazmass_shootmass)) +
  geom_histogram(bins = 20) +
  labs(x = "Grazer load", y = "Count")

## ln transformation ##
ggplot(tran.dat, aes(log(grazmass_shootmass + 0.1))) +
  geom_histogram(bins = 10) +
  labs(x = " log Grazer load", y = "Count")

shapiro.test(log(tran.dat$grazmass_shootmass + 0.1))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(grazmass_shootmass))) +
  geom_histogram(bins = 10) +
  labs(x = " sqrt Grazer load", y = "Count")

shapiro.test(sqrt(tran.dat$grazmass_shootmass))
```

Gastropod load also does not respond super well to transformations.
```{r gastropod load normality, echo=FALSE}
## raw data ##
ggplot(tran.dat, aes(gastromass_shootmass)) +
  geom_histogram(bins = 20) +
  labs(x = "Grazer load", y = "Count")

## ln transformation ##
ggplot(tran.dat, aes(log(gastromass_shootmass + 0.1))) +
  geom_histogram(bins = 10) +
  labs(x = " log Grazer load", y = "Count")

shapiro.test(log(tran.dat$gastromass_shootmass + 0.1))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(gastromass_shootmass))) +
  geom_histogram(bins = 10) +
  labs(x = " sqrt Grazer load", y = "Count")

shapiro.test(sqrt(tran.dat$gastromass_shootmass))
```

Crustacean load also does not respond super well to transformations.
```{rcrusteacean load, echo=FALSE}
## raw data ##
ggplot(tran.dat, aes(crustmass_shootmass)) +
  geom_histogram(bins = 20) +
  labs(x = "Grazer load", y = "Count")

## ln transformation ##
ggplot(tran.dat, aes(log(crustmass_shootmass + 0.1))) +
  geom_histogram(bins = 10) +
  labs(x = " log Grazer load", y = "Count")

shapiro.test(log(tran.dat$crustmass_shootmass + 0.1))

## sqrt transformation ##
ggplot(tran.dat, aes(sqrt(crustmass_shootmass))) +
  geom_histogram(bins = 10) +
  labs(x = " sqrt Grazer load", y = "Count")

shapiro.test(sqrt(tran.dat$crustmass_shootmass))
```

Crab biomass does not respoond super well to any transformations. There are a fair amount of zeros which is messing with normality. This data may need to be modeled with a zero infalted model, or something like that. But the zeros are also really important to be zeros. 
```{r crab biomass normality, echo=FALSE}
## Raw data ##
ggplot(crab.dat, aes(mass_g)) +
  geom_histogram(bins = 20) +
  labs(x = "crab mass", y = "Count")

## ln transformation ##
ggplot(crab.dat, aes(log(mass_g + 1))) +
  geom_histogram(bins = 20) +
  labs(x = "log crab mass", y = "Count")

shapiro.test(log(crab.dat$mass_g + 1))

## sqrt transformation ##
ggplot(crab.dat, aes(sqrt(mass_g))) +
  geom_histogram(bins = 20) +
  labs(x = "sqrt crab mass", y = "Count")

## Raw data > 0 ##
crab.dat.noZ <- crab.dat %>%
  filter(mass_g > 0)
  
ggplot(crab.dat.noZ, aes(mass_g)) +
  geom_histogram(bins = 20) +
  labs(x = "non zero crab mass", y = "Count")

## ln transformation > 0 ##
ggplot(crab.dat.noZ, aes(log(mass_g))) +
  geom_histogram(bins = 20) +
  labs(x = "log non zero crab mass", y = "Count")

## sqrt transformation > 0 ##
ggplot(crab.dat.noZ, aes(sqrt(mass_g))) +
  geom_histogram(bins = 20) +
  labs(x = "sqrt non zero crab mass", y = "Count")
```

## 3. Models
Each model will get its own individual hypothesis and set up but will follow the same general framework. Initially I will be copying and learning from example code from Tim Tinker. Models will use a mixed effects Bayesian modeling stucture. Fixed effects and the random effect of site will be modeled with normally distribution density funtions. Response variables will be paramterized in a way that best fits their distribution (see above). Count data (shoot density) will be modeled with a negative binomial distrbution. 

Models will exclude the two sites sampled in April. If the data have not already been excluded do that here.
```{r exclude april, echo=FALSE}
#tran.dat <- tran.dat %>% 
  #filter(site != "2017_L_01" & site != "2017_H_01")
```


### Model 1 - Aboveground biomass
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, sediment type, and light attenuation may effect aboveground biomass of eelgrass. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900.  

```{r Model 1 set up, echo=FALSE}
# Dependent observed variable: this should be whatever numeric variable you wish to analyze 
Obs <- as.numeric(tran.dat$ag_mass)

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Sedtype <- as.numeric(tran.dat$sed1_no)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Light <- as.numeric(tran.dat$light_attenu)[ii]
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting attributes of data
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.1 <- data.frame(Model = c("Model_1a","Model_1b","Model_1c","Model_1d","Model_1e","Model_1f","Model_1g", "Model_1h"), 
                        WAIC = numeric(length = 8), 
                        LOOIC = numeric(length = 8))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 1a
Aboveground biomass ~ time
```{r model 1a, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_1a.jags'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx) #, Ott = Ottindx, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1a <- WAIC
ModComp.1$WAIC[1] <- WAIC1a$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1a <- LOOIC
ModComp.1$LOOIC[1] <- LOOIC1a[3]

# WAIC Detail
WAIC.1a <- data.frame(modID = c('WAIC1a'), model = c('1a'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1a <- data.frame(modID = c('LOOIC1a'), model = c('1a'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out1a <- out
```
 
#### Model 1b
Aboveground biomass ~ time + SOI
```{r model 1b, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1b.jags'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1b <- WAIC
ModComp.1$WAIC[2] <- WAIC1b$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1b <- LOOIC
ModComp.1$LOOIC[2] <- LOOIC1b[3]

# WAIC Detail
WAIC.1b <- data.frame(modID = c('WAIC1b'), model = c('1b'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1b <- data.frame(modID = c('LOOIC1b'), model = c('1b'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1b = out
```

#### Model 1c
Aboveground biomass ~ time + SOI + sediment
```{r model 1c, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1c.jags'
savename = 'EelgrassM1c_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum,Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1c <- WAIC
ModComp.1$WAIC[3] <- WAIC1c$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1c <- LOOIC
ModComp.1$LOOIC[3] <- LOOIC1c[3]

# WAIC Detail
WAIC.1c <- data.frame(modID = c('WAIC1c'), model = c('1c'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1c <- data.frame(modID = c('LOOIC1c'), model = c('1c'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1c = out
```

#### Model 1d
Aboveground biomass ~ time + SOI + sediment + light
```{r model 1d, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1d.jags'
# savename='EelgrassM1d_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Li = Light) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3", "beta4", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method ="rjparallel", cl=cl)

post <- rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post <- rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1d <- WAIC
ModComp.1$WAIC[4] <- WAIC1d$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1d <- LOOIC
ModComp.1$LOOIC[4] <- LOOIC1d[3]

# WAIC Detail
WAIC.1d <- data.frame(modID = c('WAIC1d'), model = c('1d'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1d <- data.frame(modID = c('LOOIC1d'), model = c('1d'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1d = out
```

#### Model 1e
Aboveground biomass ~ time + quad(SOI)
```{r model 1e, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1e.jags'
# savename='EelgrassM1d_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method ="rjparallel", cl=cl)

post <- rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post <- rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC1e <- WAIC
ModComp.1$WAIC[5] <- WAIC1e$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1e <- LOOIC
ModComp.1$LOOIC[5] <- LOOIC1e[3]

# WAIC Detail
WAIC.1e <- data.frame(modID = c('WAIC1e'), model = c('1e'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1e <- data.frame(modID = c('LOOIC1e'), model = c('1e'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1e = out
```

#### Model 1f
Aboveground biomass ~ time + quad(SOI) + sediment
```{r model 1f, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1f.jags'
# savename='EelgrassM1f_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) # Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","beta3","eps","loglik") 

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC1f = WAIC
ModComp.1$WAIC[6] = WAIC1f$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1f <- LOOIC
ModComp.1$LOOIC[6] <- LOOIC1f[3]

# WAIC Detail
WAIC.1f <- data.frame(modID = c('WAICf'), model = c('1f'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1f <- data.frame(modID = c('LOOIC1f'), model = c('1f'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1f = out
```

#### Model 1g
Aboveground biomass ~ quad(time) + SOI
```{r model 1g, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1g.jags'
# savename='EelgrassM1f_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # , Sed = Sedtype, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2","eps","loglik")  

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC1g = WAIC
ModComp.1$WAIC[7] = WAIC1g$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1g <- LOOIC
ModComp.1$LOOIC[7] <- LOOIC1g[3]

# WAIC Detail
WAIC.1g <- data.frame(modID = c('WAIC1g'), model = c('1g'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1g <- data.frame(modID = c('LOOIC1g'), model = c('1g'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1g = out
```

#### Model 1h
Aboveground biomass ~ quad(time) + qaud(SOI)
```{r model 1h, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_1h.jags'
# savename='EelgrassM1h_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # , Sed = Sedtype, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2","beta2b", "eps","loglik")  

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC1h = WAIC
ModComp.1$WAIC[8] = WAIC1h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC1h <- LOOIC
ModComp.1$LOOIC[8] <- LOOIC1h[3]

# WAIC Detail
WAIC.1h <- data.frame(modID = c('WAIC1h'), model = c('1h'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.1h <- data.frame(modID = c('LOOIC1h'), model = c('1h'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out1h = out
```

### Model 1 Comparison
```{r Model 1 comparison, echo = FALSE}
# Clean up work session
stopCluster(cl = cl)
rm(out)

## WAIC ##
# Rank and organize model comparison table
modranks.WAIC <- order(ModComp.1$WAIC)
WAIC.1.full <- rbind(WAIC.1a, WAIC.1b, WAIC.1c, WAIC.1d, WAIC.1e, WAIC.1f, WAIC.1g, WAIC.1h)
comptab.WAIC <- compare(WAIC1a, WAIC1b, WAIC1c, WAIC1d, WAIC1e, WAIC1f, WAIC1g, WAIC1h)
filelist.WAIC <- row.names(comptab.WAIC)

for (i in 2:8){
  row = which(WAIC.1.full$modID == filelist.WAIC[i])
  comp = compare(eval(as.name(filelist.WAIC[i])) , eval(as.name(filelist.WAIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  WAIC.1.full$deltaWAIC[row] = comp[1]
  WAIC.1.full$deltaWAIC_se[row] = comp[2]
  WAIC.1.full$P_comp[row] = P_val
}

WAIC.1.full <- WAIC.1.full[modranks.WAIC,]
WAIC.1.full$P_comp[1] = 1
WAIC.1.full$Likelihood = exp(-0.5*WAIC.1.full$deltaWAIC)
WAIC.1.full$Likelihood[WAIC.1.full$P_comp < 0.1] = 0 
sumlik = sum(WAIC.1.full$Likelihood)
WAIC.1.full$WAICwt = WAIC.1.full$Likelihood/sumlik

# round
WAIC.1.full <- cbind(WAIC.1.full[,1:2], round(WAIC.1.full[, 3:9], 3))

## LOOIC ##
ModComp.1$LOOIC <- as.numeric(ModComp.1$LOOIC)
modranks.LOOIC <- order(ModComp.1$LOOIC)
LOOIC.1.full <- rbind(LOOIC.1a, LOOIC.1b, LOOIC.1c, LOOIC.1d, LOOIC.1e, LOOIC.1f, LOOIC.1g, LOOIC.1h)
comptab.LOOIC <- compare(LOOIC1a, LOOIC1b, LOOIC1c, LOOIC1d, LOOIC1e, LOOIC1f, LOOIC1g, LOOIC1h)
filelist.LOOIC <- row.names(comptab.LOOIC)

for (i in 2:8){
  row = which(LOOIC.1.full$modID == filelist.LOOIC[i])
  comp = compare(eval(as.name(filelist.LOOIC[i])) , eval(as.name(filelist.LOOIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  LOOIC.1.full$deltaLOOIC[row] = comp[1]
  LOOIC.1.full$deltaLOOIC_se[row] = comp[2]
}

LOOIC.1.full <- LOOIC.1.full[modranks.LOOIC,]
LOOIC.1.full$Likelihood = exp(-0.5*LOOIC.1.full$deltaLOOIC)
LOOIC.1.full$Likelihood[LOOIC.1.full$P_comp < 0.1] = 0 
sumlik = sum(LOOIC.1.full$Likelihood)
LOOIC.1.full$LOOICwt = LOOIC.1.full$Likelihood/sumlik

# round
LOOIC.1.full <- cbind(LOOIC.1.full[,1:2], round(LOOIC.1.full[, 3:8], 3))
```

### Model 1 Best model comparison tables
WAIC Comparison
```{r model 1 WAIC, echo = FALSE}
DT::datatable(WAIC.1.full)

# Write
write.csv(WAIC.1.full, "EG_Mod1_WAIC.csv", row.names = FALSE)
```

LOICC comparison
```{r model 1 LOOIC, echo = FALSE}
DT::datatable(LOOIC.1.full)

# Write
write.csv(LOOIC.1.full, "EG_Mod1_LOOIC.csv", row.names = FALSE)
```

#### Model 1 Best model comparison plots
Top three models
```{r Model 1 full model plots }
plot(out1h, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 4))

plot(out1g, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 4))

plot(out1b, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 4))
```

Posteriors only
```{r posteriors only}
plot(out1h, "histogram", vars = c("sig", "beta"), layout = c(1, 7))
plot(out1g, "histogram", vars = c("sig", "beta"), layout = c(1, 7))
plot(out1b, "histogram", vars = c("sig", "beta"), layout = c(1, 7))
```

```{r top models table}
## Model 1h summary stats ##
sum.1h <- add.summary(out1h, c("sig","beta"))
sumstats.1h <- as.data.frame(sum.1h$summaries)
sumstats.1h$Coef <- rownames(sumstats.1h)
sumstats.1h$Model <- "1h"

## Model 1g summary stats ##
sum.1g <- add.summary(out1g, c("sig","beta"))
sumstats.1g <- as.data.frame(sum.1g$summaries)
sumstats.1g$Coef <- rownames(sumstats.1g)
sumstats.1g$Model <- "1g"

## Model 1b summary stats ##
sum.1b <- add.summary(out1b, c("sig","beta"))
sumstats.1b <- as.data.frame(sum.1b$summaries)
sumstats.1b$Coef <- rownames(sumstats.1b)
sumstats.1b$Model <- "1b"

## All Together Now ##
sumstats.1 <- rbind(sumstats.1h, sumstats.1g, sumstats.1b)
rownames(sumstats.1) <- c()
sumstats.1 <- cbind(sumstats.1[, c(13, 12)], round(sumstats.1[, 1:11], 4))

# Change names #
sumstats.1$Coef <- recode(sumstats.1$Coef, sigS = "among site", sigO = "within site", beta1 = "time", beta1b = "time^2", beta2 = "SOI", beta2b = "SOI^2", beta0 = "intercept")

DT::datatable(sumstats.1)

# Save ##
write.csv(sumstats.1, "EG_Mod1_sumstats.csv", row.names = FALSE)
```

```{r plots?}
ggplot(sumstats.1, aes(color = Model)) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_linerange(aes(Coef, ymin = Lower95, ymax = Upper95), lwd = 1.5, position = position_dodge(width = 1/2)) +
  geom_point(aes(Coef, Median), size = 3, position = position_dodge(width = 1/2)) +
  coord_flip() + 
  scale_y_continuous(breaks = seq(-1.5, 4, by = 0.5)) +
  labs(x = "Coefficient Name", y = " Coefficient Value +/- CI")
```

### Model 1 Plotting best model
```{r model 1 plotting best model, echo=FALSE}
#eval(parse(text=paste0("out = out",modranks[1]))) 

# Extract MCMC values
post <- rbind(out1h$mcmc[[1]], out1h$mcmc[[2]])

# Loop over number of cores
for (i in 3:nc){
  post <- rbind(post, out1h$mcmc[[i]])
}

# Calculate summary stats
reps <- dim(post)[1]
sumout <- add.summary(out1h, c("sig","beta"))
sumstats <- sumout$summaries
vn <- row.names(sumstats)

# Diagnostic plots
plot(out1h, c('trace', 'histogram'), vars=c("sig","beta"))

# Create dataframes for plotting fixed effects: assume Model1h
mind <- min(Dayindx)
maxd <- max(Dayindx)
Julday <- numeric(length = length(seq(mind:maxd)))
Predict <- numeric(length = length(seq(mind:maxd)))
Lwr <- numeric(length = length(seq(mind:maxd)))
Upr <- numeric(length = length(seq(mind:maxd)))
sig <- post[,which(vn == 'sigO')]
bt0 <- post[,which(vn == 'beta0')]
bt1 <- post[,which(vn == 'beta1')]
bt1b <- post[,which(vn == 'beta1b')]
bt2 <- post[,which(vn == 'beta2')]
bt2b <- post[,which(vn == 'beta2b')]

for (d in mind:maxd){
  Julday[d] = d - 1 + Minday
  Mu = bt0 + bt1*d + bt1b*d^2
  Predict[d] = mean(exp(Mu + sig^2/2))
  Lwr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .975))
} 

dfDay = data.frame(Julianday = Julday, Mean = Predict, Lwr = Lwr, Upr = Upr)
dfData = data.frame(x = Julianday, y = Obs)

p1 <- ggplot(dfDay, aes(x = Julianday, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  # geom_point(data = dfData, aes(x=x, y=y))+
  xlab('Julian Day') + 
  ylab(bquote('Predicted aboveground mass +/- 95% CI ' ~(g/m^2))) +
  scale_x_continuous(breaks = seq(119, 240, by = 30)) +
  scale_y_continuous(breaks = seq(0, 250, by = 50)) +
  theme(text = element_text(size = 12), axis.ticks = element_line(size = 2), legend.position = "none")

# save plot
ggsave("Mod1h_time.png", p1, dpi = 400)

Ottvals <- seq(min(Ottindx), max(Ottindx), length.out = 100)
Predict <- numeric(length = 100)
Lwr <- numeric(length = 100)
Upr <- numeric(length = 100)

for (o in 1:100){
  Mu <- bt0 + bt1*MeanDay + bt1b*MeanDay^2 + bt2*Ottvals[o] + bt2b*Ottvals[o]^2
  Predict[o] <- mean(exp(Mu + sig^2/2))
  Lwr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .975))
}

dfOtt = data.frame(OtterIndex = Ottvals, Mean = Predict, Lwr = Lwr, Upr = Upr)

p2 <- ggplot(dfOtt, aes(x = OtterIndex, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  xlab('Sea Otter Index') + 
  ylab(bquote('Predicted aboveground mass +/- 95% CI ' ~(g/m^2))) +
  #scale_x_continuous(breaks = seq(-1, 1, by = 0.25)) +
  #scale_y_continuous(breaks = seq(0, 250, by = 50)) +
  theme(text = element_text(size = 12), axis.ticks = element_line(size = 2), legend.position = "none")

# save plot
ggsave("Mod1h_SOI.png", p2, dpi = 400)

plot_grid(p1, p2, nrow = 2, ncol = 1)
```

### Model 2 - Belowground biomass
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, sediment type, and light attenuation may effect belowground biomass of eelgrass. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900.  

```{r Model 2 set up, echo=FALSE}
# Dependent observed variable: this should be whatever numeric variable you wish to analyze 
Obs <- as.numeric(tran.dat$bg_mass)

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Sedtype <- as.numeric(tran.dat$sed1_no)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Light <- as.numeric(tran.dat$light_attenu)[ii]
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting stuff?
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.2 <- data.frame(Model = c("Model_2a","Model_2b","Model_2c","Model_2d","Model_2e","Model_2f","Model_2g", "Model_2h"), 
                        WAIC = numeric(length = 8), 
                        LOOIC = numeric(length = 8))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 2a
Belowground biomass ~ time
```{r model 2a, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2a.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx) #, Ott = Ottindx, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2a <- WAIC
ModComp.2$WAIC[1] <- WAIC2a$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2a <- LOOIC
ModComp.2$LOOIC[1] <- LOOIC2a[3]

# WAIC Detail
WAIC.2a <- data.frame(modID = c('WAIC2a'), model = c('2a'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2a <- data.frame(modID = c('LOOIC2a'), model = c('2a'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2a <- out
```

#### Model 2b
Belowground biomass ~ time + SOI
```{r model 2b, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2b.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1", "beta2", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2b <- WAIC
ModComp.2$WAIC[2] <- WAIC2b$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2b <- LOOIC
ModComp.2$LOOIC[2] <- LOOIC2b[3]

# WAIC Detail
WAIC.2b <- data.frame(modID = c('WAIC2b'), model = c('2b'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2b <- data.frame(modID = c('LOOIC2b'), model = c('2b'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2b <- out
```

#### Model 2c 
Belowground biomass ~ time + SOI + Sediment
```{r model 2c, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2c.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2c <- WAIC
ModComp.2$WAIC[3] <- WAIC2c$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2c <- LOOIC
ModComp.2$LOOIC[3] <- LOOIC2c[3]

# WAIC Detail
WAIC.2c <- data.frame(modID = c('WAIC2c'), model = c('2c'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2c <- data.frame(modID = c('LOOIC2c'), model = c('2c'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2c <- out
```

#### Model 2d 
Belowground biomass ~ time + SOI + Sediment + Light
```{r model 2d, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2d.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Li = Light) #  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3", "beta4", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2d <- WAIC
ModComp.2$WAIC[4] <- WAIC2d$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2d <- LOOIC
ModComp.2$LOOIC[4] <- LOOIC2d[3]

# WAIC Detail
WAIC.2d <- data.frame(modID = c('WAIC2d'), model = c('2d'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2d <- data.frame(modID = c('LOOIC2d'), model = c('2d'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2d <- out
```

#### Model 2e 
Belowground biomass ~ time + quad(SOI)
```{r model 2e, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_2e.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype, Li = Light) #  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC2e <- WAIC
ModComp.2$WAIC[5] <- WAIC2e$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2e <- LOOIC
ModComp.2$LOOIC[5] <- LOOIC2e[3]

# WAIC Detail
WAIC.2e <- data.frame(modID = c('WAIC2e'), model = c('2e'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2e <- data.frame(modID = c('LOOIC2e'), model = c('2e'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2e <- out
```

#### Model 2f
Belowground biomass ~ time + quad(SOI) + sediment
```{r model 2f, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_2f.jags'
# savename='EelgrassM1f_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) # Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","beta3","eps","loglik") 

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC2f = WAIC
ModComp.2$WAIC[6] = WAIC2f$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2f <- LOOIC
ModComp.2$LOOIC[6] <- LOOIC2f[3]

# WAIC Detail
WAIC.2f <- data.frame(modID = c('WAIC2f'), model = c('2f'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2f <- data.frame(modID = c('LOOIC2f'), model = c('2f'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2f = out
```

#### Model 2g
Belowground biomass ~ quad(time) + SOI
```{r model 2g, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_2g.jags'
# savename='EelgrassM1f_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # , Sed = Sedtype, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2","eps","loglik")  

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC2g = WAIC
ModComp.2$WAIC[7] = WAIC2g$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2g <- LOOIC
ModComp.2$LOOIC[7] <- LOOIC2g[3]

# WAIC Detail
WAIC.2g <- data.frame(modID = c('WAIC2g'), model = c('2g'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2g <- data.frame(modID = c('LOOIC2g'), model = c('2g'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))
out2g = out
```

#### Model 2h
Belowground biomass ~ quad(time) + qaud(SOI)
```{r model 2h, echo=FALSE}
jagsfile = 'JAGS/Eelgrass_2h.jags'
# savename='EelgrassM1h_Results.Rdata'
jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # , Sed = Sedtype, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2","beta2b", "eps","loglik")  

# Call JAGS from R
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC = waic(mc_ll)
WAIC2h = WAIC
ModComp.2$WAIC[8] = WAIC2h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC2h <- LOOIC
ModComp.2$LOOIC[8] <- LOOIC2h[3]

# WAIC Detail
WAIC.2h <- data.frame(modID = c('WAIC2h'), model = c('2h'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.2h <- data.frame(modID = c('LOOIC2h'), model = c('2h'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out2h = out
```

### Model 2 Comparison
```{r Model 2 comparison, echo = FALSE}
# Clean up work session
stopCluster(cl = cl)
rm(out)

## WAIC ##
# Rank and organize model comparison table
modranks.WAIC <- order(ModComp.2$WAIC)
WAIC.2.full <- rbind(WAIC.2a, WAIC.2b, WAIC.2c, WAIC.2d, WAIC.2e, WAIC.2f, WAIC.2g, WAIC.2h)
comptab.WAIC <- compare(WAIC2a, WAIC2b, WAIC2c, WAIC2d, WAIC2e, WAIC2f, WAIC2g, WAIC2h)
filelist.WAIC <- row.names(comptab.WAIC)

# Calculate comaprison values
for (i in 2:8){
  row = which(WAIC.2.full$modID == filelist.WAIC[i])
  comp = compare(eval(as.name(filelist.WAIC[i])) , eval(as.name(filelist.WAIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  WAIC.2.full$deltaWAIC[row] = comp[1]
  WAIC.2.full$deltaWAIC_se[row] = comp[2]
  WAIC.2.full$P_comp[row] = P_val
}

# organize final table
WAIC.2.full <- WAIC.2.full[modranks.WAIC,]
WAIC.2.full$P_comp[1] = 1
WAIC.2.full$Likelihood = exp(-0.5*WAIC.2.full$deltaWAIC)
WAIC.2.full$Likelihood[WAIC.2.full$P_comp < 0.1] = 0 
sumlik = sum(WAIC.2.full$Likelihood)
WAIC.2.full$WAICwt = WAIC.2.full$Likelihood/sumlik

# round
WAIC.2.full <- cbind(WAIC.2.full[,1:2], round(WAIC.2.full[, 3:8], 3))

## LOOIC ##
# Rank and organize model comparison table
ModComp.2$LOOIC <- as.numeric(ModComp.2$LOOIC)
modranks.LOOIC <- order(ModComp.2$LOOIC)
LOOIC.2.full <- rbind(LOOIC.2a, LOOIC.2b, LOOIC.2c, LOOIC.2d, LOOIC.2e, LOOIC.2f, LOOIC.2g, LOOIC.2h)
comptab.LOOIC <- compare(LOOIC2a, LOOIC2b, LOOIC2c, LOOIC2d, LOOIC2e, LOOIC2f, LOOIC2g, LOOIC2h)
filelist.LOOIC <- row.names(comptab.LOOIC)

# Calculate comparison values
for (i in 2:8){
  row = which(LOOIC.2.full$modID == filelist.LOOIC[i])
  comp = compare(eval(as.name(filelist.LOOIC[i])) , eval(as.name(filelist.LOOIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  LOOIC.2.full$deltaLOOIC[row] = comp[1]
  LOOIC.2.full$deltaLOOIC_se[row] = comp[2]
}

# organize final table
LOOIC.2.full <- LOOIC.2.full[modranks.LOOIC,]
LOOIC.2.full$Likelihood = exp(-0.5*LOOIC.2.full$deltaLOOIC)
LOOIC.2.full$Likelihood[LOOIC.2.full$P_comp < 0.1] = 0 
sumlik = sum(LOOIC.2.full$Likelihood)
LOOIC.2.full$LOOICwt = LOOIC.2.full$Likelihood/sumlik

# round
LOOIC.2.full <- cbind(LOOIC.2.full[,1:2], round(LOOIC.2.full[, 3:8], 3))
```

### Model 2 Comparison tables
WAIC Comparison
```{r model 2 WAIC, echo = FALSE}
DT::datatable(WAIC.2.full)

# Write
write.csv(WAIC.2.full, "EG_Mod2_WAIC.csv", row.names = FALSE)
```

LOICC comparison
```{r model 2 LOOIC, echo = FALSE}
DT::datatable(LOOIC.2.full)

# Write
write.csv(LOOIC.2.full, "EG_Mod2_LOOIC.csv", row.names = FALSE)
```

#### Model 2 Best model comparison plots
Top three models
```{r Model 1 full model plots }
plot(out1b, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 4))

plot(out1a, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 4))

plot(out1e, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 4))
```

Posteriors only
```{r posteriors only}
plot(out1b, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
plot(out1a, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
plot(out1e, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
```

```{r top models table}
## Model 2b summary stats ##
sum.2b <- add.summary(out2b, c("sig","beta"))
sumstats.2b <- as.data.frame(sum.2b$summaries)
sumstats.2b$Coef <- rownames(sumstats.2b)
sumstats.2b$Model <- "2b"

## Model 2a summary stats ##
sum.2a <- add.summary(out2a, c("sig","beta"))
sumstats.2a <- as.data.frame(sum.2a$summaries)
sumstats.2a$Coef <- rownames(sumstats.2a)
sumstats.2a$Model <- "2a"

## Model 2e summary stats ##
sum.2e <- add.summary(out2e, c("sig","beta"))
sumstats.2e <- as.data.frame(sum.2e$summaries)
sumstats.2e$Coef <- rownames(sumstats.2e)
sumstats.2e$Model <- "2e"

## All Together Now ##
sumstats.2 <- rbind(sumstats.2b, sumstats.2a, sumstats.2e)
rownames(sumstats.2) <- c()
sumstats.2 <- cbind(sumstats.2[, c(13, 12)], round(sumstats.2[, 1:11], 4))

# Change names #
sumstats.2$Coef <- recode(sumstats.2$Coef, sigS = "among site", sigO = "within site", beta1 = "time", beta1b = "time^2", beta2 = "SOI", beta2b = "SOI^2", beta0 = "intercept")

DT::datatable(sumstats.2)

# Save ##
write.csv(sumstats.2, "EG_Mod2_sumstats.csv", row.names = FALSE)
```

```{r plots?}
ggplot(sumstats.2, aes(color = Model)) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_linerange(aes(Coef, ymin = Lower95, ymax = Upper95), lwd = 1.5, position = position_dodge(width = 1/2)) +
  geom_point(aes(Coef, Median), size = 3, position = position_dodge(width = 1/2)) +
  coord_flip() + 
  scale_y_continuous(breaks = seq(-1.5, 4, by = 0.5)) +
  labs(x = "Coefficient Name", y = " Coefficient Value +/- CI")
```

### Model 2 Plotting best model
If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model.
```{r model 2 plotting best model, echo=FALSE}
# Extract best model
best2.WAIC <- paste0(c("out", paste0(WAIC.2.full[1,2])), collapse = "")
best2.LOOIC <- paste0(c("out", paste0(LOOIC.2.full[1,2])), collapse = "")

# Test for difference in best model between WAIC and LOOIC. If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model
ifelse(all.equal(best2.WAIC, best2.LOOIC) == TRUE, best2 <- eval(best2.WAIC), best2 <- eval(best2.LOOIC))

# Extract MCMC values
post <- rbind(out2b$mcmc[[1]], out2b$mcmc[[2]])

# Loop over number of cores
for (i in 3:nc){
  post <- rbind(post, out2b$mcmc[[i]])
}

# Calculate summary stats
reps <- dim(post)[1]
sumout <- add.summary(out2b, c("sig","beta"))
sumstats <- sumout$summaries
vn <- row.names(sumstats)

# Diagnostic plots
plot(out2b, c('trace', 'histogram'), vars=c("sig","beta"))

# Create dataframes for plotting fixed effects: assume Model2a
mind <- min(Dayindx)
maxd <- max(Dayindx)
Julday <- numeric(length = length(seq(mind:maxd)))
Predict <- numeric(length = length(seq(mind:maxd)))
Lwr <- numeric(length = length(seq(mind:maxd)))
Upr <- numeric(length = length(seq(mind:maxd)))
sig <- post[,which(vn == 'sigO')]
bt0 <- post[,which(vn == 'beta0')]
bt1 <- post[,which(vn == 'beta1')]
bt2 <- post[,which(vn == "beta2")]

for (d in mind:maxd){
  Julday[d] = d - 1 + Minday
  Mu = bt0 + bt1*d
  Predict[d] = mean(exp(Mu + sig^2/2))
  Lwr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .975))
} 

dfDay = data.frame(Julianday = Julday, Mean = Predict, Lwr = Lwr, Upr = Upr)
dfData = data.frame(x = Julianday, y = Obs)

p1 <- ggplot(dfDay, aes(x = Julianday, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  # geom_point(data = dfData, aes(x=x, y=y))+
  xlab('Julian Day') + 
  ylab(bquote('Predicted belowground mass +/- 95% CI ' ~(g/m^2))) +
  theme(text = element_text(size = 12), axis.ticks = element_line(size = 2), legend.position = "none")

# save plot
ggsave("Mod2b_time.png", p1, dpi = 400)

Ottvals <- seq(min(Ottindx), max(Ottindx), length.out = 100)
Predict <- numeric(length = 100)
Lwr <- numeric(length = 100)
Upr <- numeric(length = 100)

for (o in 1:100){
  Mu <- bt0 + bt1*MeanDay + bt2*Ottvals[o] 
  Predict[o] <- mean(exp(Mu + sig^2/2))
  Lwr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .975))
}

dfOtt = data.frame(OtterIndex = Ottvals, Mean = Predict, Lwr = Lwr, Upr = Upr)

p2 <- ggplot(dfOtt, aes(x = OtterIndex, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  xlab('Sea Otter Index') + 
  ylab(bquote('Predicted belowground mass +/- 95% CI ' ~(g/m^2))) +
  theme(text = element_text(size = 12), axis.ticks = element_line(size = 2), legend.position = "none")

# save plot
ggsave("Mod2b_SOI.png", p2, dpi = 400)
```

### Model 3 - Shoot Density
Responce is negative binomially distributed count data. We hypothesise that time (as julian day), sea otter index, sediment type, and light attenuation may effect belowground biomass of eelgrass.

```{r model 3 set up, echo = FALSE}
# Dependent observed variable: eeglrass shoot density per meter sq
Obs <- as.numeric(tran.dat$eelgrass_shoots_msq)

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Sedtype <- as.numeric(tran.dat$sed1_no)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Light <- as.numeric(tran.dat$light_attenu)[ii]
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting data attributes
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.3 <- data.frame(Model = c("Model_3a","Model_3b","Model_3c","Model_3d","Model_3e","Model_3f","Model_3g", "Model_3h", "Model_3i"), WAIC = numeric(length = 9), LOOIC = numeric(length = 9))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 3a
Shoot density ~ time
```{r model 3a, echo = FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3a.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx) # Ott = Ottindx, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0","beta1","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3a <- WAIC
ModComp.3$WAIC[1] <- WAIC3a$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3a <- LOOIC
ModComp.3$LOOIC[1] <- LOOIC3a[3]

# WAIC Detail
WAIC.3a <- data.frame(modID = c('WAIC3a'), model = c('3a'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3a <- data.frame(modID = c('LOOIC3a'), model = c('3a'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3a <- out
```

#### Model 3b
Shoot density ~ time + SOI
```{r model 3b, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3b.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, , Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers","beta0","beta1","beta2", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3b <- WAIC
ModComp.3$WAIC[2] <- WAIC3b$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3b <- LOOIC
ModComp.3$LOOIC[2] <- LOOIC3b[3]

# WAIC Detail
WAIC.3b <- data.frame(modID = c('WAIC3b'), model = c('3b'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3b <- data.frame(modID = c('LOOIC3b'), model = c('3b'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3b <- out
```

#### Model 3c
Shoot density ~ time + SOI + Sediment
```{r model 3c, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3c.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #, ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers","beta0","beta1","beta2", "beta3", "eps","loglik")  

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3c <- WAIC
ModComp.3$WAIC[3] <- WAIC3c$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3c <- LOOIC
ModComp.3$LOOIC[3] <- LOOIC3c[3]

# WAIC Detail
WAIC.3c <- data.frame(modID = c('WAIC3c'), model = c('3c'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3c <- data.frame(modID = c('LOOIC3c'), model = c('3c'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3c <- out
```

#### Model 3d
Shoot density ~ time + SOI + Sediment + Light
```{r model 3d, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3d.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Li = Light) #, ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta2", "beta3", "beta4", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3d <- WAIC
ModComp.3$WAIC[4] <- WAIC3d$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3d <- LOOIC
ModComp.3$LOOIC[4] <- LOOIC3d[3]

# WAIC Detail
WAIC.3d <- data.frame(modID = c('WAIC3d'), model = c('3d'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3d <- data.frame(modID = c('LOOIC3d'), model = c('3d'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3d <- out
```

#### Model 3e
Shoot density ~ time + quad(SOI)
```{r model 3e, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3e.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype, Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta2", "beta2b", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3e <- WAIC
ModComp.3$WAIC[5] <- WAIC3e$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3e <- LOOIC
ModComp.3$LOOIC[5] <- LOOIC3e[3]

# WAIC Detail
WAIC.3e <- data.frame(modID = c('WAIC3e'), model = c('3e'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3e <- data.frame(modID = c('LOOIC3e'), model = c('3e'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3e <- out
```

#### Model 3f
Shoot density ~ time + quad(SOI) + sediment
```{r model 3f, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3f.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) # , Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta2", "beta2b", "beta3", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3f <- WAIC
ModComp.3$WAIC[6] <- WAIC3f$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3f <- LOOIC
ModComp.3$LOOIC[6] <- LOOIC3f[3]

# WAIC Detail
WAIC.3f <- data.frame(modID = c('WAIC3f'), model = c('3f'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3f <- data.frame(modID = c('LOOIC3f'), model = c('3f'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3f <- out
```

#### Model 3g
Shoot density ~ quad(time) + SOI
```{r model 3g, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3g.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # Sed = Sedtype Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta1b", "beta2", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3g <- WAIC
ModComp.3$WAIC[7] <- WAIC3g$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3g <- LOOIC
ModComp.3$LOOIC[7] <- LOOIC3g[3]

# WAIC Detail
WAIC.3g <- data.frame(modID = c('WAIC3g'), model = c('3g'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3g <- data.frame(modID = c('LOOIC3g'), model = c('3g'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3g <- out
```

#### Model 3h
Shoot density ~ quad(time) + quad(SOI)
```{r model 3h, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3h.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # Sed = Sedtype Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta1", "beta1b", "beta2", "beta2b", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3h <- WAIC
ModComp.3$WAIC[8] <- WAIC3h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3h <- LOOIC
ModComp.3$LOOIC[8] <- LOOIC3h[3]

# WAIC Detail
WAIC.3h <- data.frame(modID = c('WAIC3h'), model = c('3h'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3h <- data.frame(modID = c('LOOIC3h'), model = c('3h'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3h <- out
```

#### Model 3i
Shoot density ~ quad(SOI)
```{r model 3i, echo=FLASE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_3i.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Ott = Ottindx) # Sed = Sedtype Li = Light ,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), Dispers = runif(1, .1, 1)) 

params <- c("sigS","Dispers", "beta0", "beta2", "beta2b", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC3i <- WAIC
ModComp.3$WAIC[9] <- WAIC3h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC3i <- LOOIC
ModComp.3$LOOIC[9] <- LOOIC3h[3]

# WAIC Detail
WAIC.3i <- data.frame(modID = c('WAIC3i'), model = c('3i'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.3i <- data.frame(modID = c('LOOIC3i'), model = c('3i'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out3i <- out
```

### Model 3 Comparison
```{r Model 3 comparison, echo = FALSE}
# Clean up work session
stopCluster(cl = cl)
rm(out)

## WAIC ##
# Rank and organize model comparison table
modranks.WAIC <- order(ModComp.3$WAIC)
WAIC.3.full <- rbind(WAIC.3a, WAIC.3b, WAIC.3c, WAIC.3d, WAIC.3e, WAIC.3f, WAIC.3g, WAIC.3h, WAIC.3i)
comptab.WAIC <- compare(WAIC3a, WAIC3b, WAIC3c, WAIC3d, WAIC3e, WAIC3f, WAIC3g, WAIC3h, WAIC3i)
filelist.WAIC <- row.names(comptab.WAIC)

# Calculate comaprison values
for (i in 2:9){
  row = which(WAIC.3.full$modID == filelist.WAIC[i])
  comp = compare(eval(as.name(filelist.WAIC[i])) , eval(as.name(filelist.WAIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  WAIC.3.full$deltaWAIC[row] = comp[1]
  WAIC.3.full$deltaWAIC_se[row] = comp[2]
  WAIC.3.full$P_comp[row] = P_val
}

# organize final table
WAIC.3.full <- WAIC.3.full[modranks.WAIC,]
WAIC.3.full$P_comp[1] = 1
WAIC.3.full$Likelihood = exp(-0.5*WAIC.3.full$deltaWAIC)
WAIC.3.full$Likelihood[WAIC.3.full$P_comp < 0.1] = 0 
sumlik = sum(WAIC.3.full$Likelihood)
WAIC.3.full$WAICwt = WAIC.3.full$Likelihood/sumlik

# round
WAIC.3.full <- cbind(WAIC.3.full[,1:2], round(WAIC.3.full[, 3:8], 3))

## LOOIC ##
# Rank and organize model comparison table
ModComp.3$LOOIC <- as.numeric(ModComp.3$LOOIC)
modranks.LOOIC <- order(ModComp.3$LOOIC)
LOOIC.3.full <- rbind(LOOIC.3a, LOOIC.3b, LOOIC.3c, LOOIC.3d, LOOIC.3e, LOOIC.3f, LOOIC.3g, LOOIC.3h, LOOIC.3i)
comptab.LOOIC <- compare(LOOIC3a, LOOIC3b, LOOIC3c, LOOIC3d, LOOIC3e, LOOIC3f, LOOIC3g, LOOIC3h, LOOIC3i)
filelist.LOOIC <- row.names(comptab.LOOIC)

# Calculate comparison values
for (i in 2:9){
  row = which(LOOIC.3.full$modID == filelist.LOOIC[i])
  comp = compare(eval(as.name(filelist.LOOIC[i])) , eval(as.name(filelist.LOOIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  LOOIC.3.full$deltaLOOIC[row] = comp[1]
  LOOIC.3.full$deltaLOOIC_se[row] = comp[2]
}

# organize final table
LOOIC.3.full <- LOOIC.3.full[modranks.LOOIC,]
LOOIC.3.full$Likelihood = exp(-0.5*LOOIC.3.full$deltaLOOIC)
LOOIC.3.full$Likelihood[LOOIC.3.full$P_comp < 0.1] = 0 
sumlik = sum(LOOIC.3.full$Likelihood)
LOOIC.3.full$LOOICwt = LOOIC.3.full$Likelihood/sumlik

# round
LOOIC.3.full <- cbind(LOOIC.3.full[,1:2], round(LOOIC.3.full[, 3:8], 3))
```

### Model 3 Comparison tables
WAIC Comparison
```{r model 3 WAIC, echo = FALSE}
DT::datatable(WAIC.3.full)

write.csv(WAIC.3.full, "EG_Mod3_WAIC.csv", row.names = FALSE)
```

LOICC comparison
```{r model 3 LOOIC, echo = FALSE}
DT::datatable(LOOIC.3.full)

write.csv(LOOIC.3.full, "EG_Mod3_LOOIC.csv", row.names = FALSE)
```

#### Model 3 Best model comparison plots
Top three models
```{r Model 1 full model plots }
plot(out3a, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(3, 2))

plot(out3e, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(5, 2))

plot(out3b, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(3, 4))
```

Posteriors only
```{r posteriors only}
plot(out3a, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
plot(out3e, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
plot(out3b, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
```

```{r top models table}
## Model 3b summary stats ##
sum.3a <- add.summary(out3a, c("sig","beta"))
sumstats.3a <- as.data.frame(sum.3a$summaries)
sumstats.3a$Coef <- rownames(sumstats.3a)
sumstats.3a$Model <- "3a"

## Model 3a summary stats ##
sum.3e <- add.summary(out3e, c("sig","beta"))
sumstats.3e <- as.data.frame(sum.3e$summaries)
sumstats.3e$Coef <- rownames(sumstats.3e)
sumstats.3e$Model <- "3e"

## Model 3b summary stats ##
sum.3b <- add.summary(out3b, c("sig","beta"))
sumstats.3b <- as.data.frame(sum.3b$summaries)
sumstats.3b$Coef <- rownames(sumstats.3b)
sumstats.3b$Model <- "3b"

## All Together Now ##
sumstats.3 <- rbind(sumstats.3a, sumstats.3e, sumstats.3b)
rownames(sumstats.3) <- c()
sumstats.3 <- cbind(sumstats.3[, c(13, 12)], round(sumstats.3[, 1:11], 4))

# Change names #
sumstats.3$Coef <- recode(sumstats.3$Coef, sigS = "among site", sigO = "within site", beta1 = "time", beta1b = "time^2", beta2 = "SOI", beta2b = "SOI^2", beta3 = "sediment", beta0 = "intercept")

DT::datatable(sumstats.3)

# Save ##
write.csv(sumstats.3, "EG_Mod3_sumstats.csv", row.names = FALSE)
```

```{r plots?}
ggplot(sumstats.3, aes(color = Model)) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_linerange(aes(Coef, ymin = Lower95, ymax = Upper95), lwd = 1.5, position = position_dodge(width = 1/2)) +
  geom_point(aes(Coef, Median), size = 3, position = position_dodge(width = 1/2)) +
  coord_flip() + 
  scale_y_continuous(breaks = seq(-5, 6, by = 1)) +
  labs(x = "Coefficient Name", y = " Coefficient Value +/- CI")
```


### Model 3 Plotting best model
THIS IS NOT OPERATIONAL If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model.
```{r model 3 plotting best model, echo=FALSE}
# Extract best model
best3.WAIC <- paste0(c("out", paste0(WAIC.3.full[1,2])), collapse = "")
best3.LOOIC <- paste0(c("out", paste0(LOOIC.3.full[1,2])), collapse = "")

# Test for difference in best model between WAIC and LOOIC. If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model
ifelse(all.equal(best3.WAIC, best3.LOOIC) == TRUE, best2 <- eval(best3.WAIC), best2 <- eval(best3.LOOIC))

# Extract MCMC values
post <- rbind(out3e$mcmc[[1]], out3e$mcmc[[2]])

# Loop over number of cores
for (i in 3:nc){
  post <- rbind(post, out3e$mcmc[[i]])
}

# Calculate summary stats
reps <- dim(post)[1]
sumout <- add.summary(out3e, c("sig","beta", "Dispers"))
sumstats <- sumout$summaries
vn <- row.names(sumstats)

# Diagnostic plots
plot(out3e, c('trace', 'histogram'), vars=c("sig","Dispers","beta"), layout = c(6, 2))

# Create dataframes for plotting fixed effects
mind <- min(Dayindx)
maxd <- max(Dayindx)
Julday <- numeric(length = length(seq(mind:maxd)))
Predict <- numeric(length = length(seq(mind:maxd)))
Lwr <- numeric(length = length(seq(mind:maxd)))
Upr <- numeric(length = length(seq(mind:maxd)))
sig <- post[,which(vn == 'sigS')]
dis <- post[,which(vn == 'Dispers')]
bt0 <- post[,which(vn == 'beta0')]
bt1 <- post[,which(vn == 'beta1')]
bt2 <- post[,which(vn == 'beta2')]
bt2b <- post[,which(vn == 'beta2b')]

for (d in mind:maxd){
  Julday[d] = d - 1 + Minday
  ldayMu = bt0 + bt1*d
  Predict[d] = mean(exp(ldayMu + sig))
  Lwr[d] = as.numeric(quantile(exp(ldayMu + sig), .025))
  Upr[d] = as.numeric(quantile(exp(ldayMu + sig), .975))
} 

dfDay = data.frame(Julianday = Julday, Mean = Predict, Lwr = Lwr, Upr = Upr)
dfData = data.frame(x = Julianday, y = Obs)

p1 <- ggplot(dfDay, aes(x = Julianday, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  # geom_point(data = dfData, aes(x=x, y=y))+
  xlab('Julian Day') + 
  ylab(bquote('Predicted shoot density' ~(m^2))) +
  theme(legend.position = "none")

print(p1)

Ottvals <- seq(min(Ottindx), max(Ottindx), length.out = 100)
Predict <- numeric(length = 100)
Lwr <- numeric(length = 100)
Upr <- numeric(length = 100)

for (o in 1:100){
  Mu <- bt0 + bt1*MeanDay + bt2*Ottvals[o] + bt2b*Ottvals[o]^2
  Predict[o] <- mean(exp(Mu + sig^2/2))
  Lwr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .975))
}

dfOtt = data.frame(OtterIndex = Ottvals, Mean = Predict, Lwr = Lwr, Upr = Upr)

p2 <- ggplot(dfOtt, aes(x = OtterIndex, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  xlab('Sea Otter Index') + 
  ylab(bquote('Mean Pred aboveground mass' ~(g/m^2))) +
  theme(legend.position = "none")

plot_grid(p1, p2, nrow = 2, ncol = 1)
```

### Model 4 - Aboveground to belowground biomass.
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, sediment type, and light attenuation may effect belowground biomass of eelgrass. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900.

```{r Model 4 set up, echo=FALSE}
# Dependent observed variable: this should be whatever numeric variable you wish to analyze 
Obs <- as.numeric(tran.dat$agbg_mass)

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Sedtype <- as.numeric(tran.dat$sed1_no)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Light <- as.numeric(tran.dat$light_attenu)[ii]
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting attributes of data
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.4 <- data.frame(Model = c("Model_4a","Model_4b","Model_4c","Model_4d","Model_4e","Model_4f","Model_4g", "Model_4h"), WAIC = numeric(length = 8), LOOIC = numeric(length = 8))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 4a
AG/BG ~ time
```{r model 4a, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4a.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx) #, Ott = Ottindx, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4a <- WAIC
ModComp.4$WAIC[1] <- WAIC4a$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4a <- LOOIC
ModComp.4$LOOIC[1] <- LOOIC4a[3]

# WAIC Detail
WAIC.4a <- data.frame(modID = c('WAIC4a'), model = c('4a'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4a <- data.frame(modID = c('LOOIC4a'), model = c('4a'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4a <- out
```

#### Model 4b
AG/BG ~ time + SOI
```{r model 4b, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4b.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4b <- WAIC
ModComp.4$WAIC[2] <- WAIC4b$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4b <- LOOIC
ModComp.4$LOOIC[2] <- LOOIC4b[3]

# WAIC Detail
WAIC.4b <- data.frame(modID = c('WAIC4b'), model = c('4b'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4b <- data.frame(modID = c('LOOIC4b'), model = c('4b'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4b <- out
```

#### Model 4c
AG/BG ~ time + SOI + sediment
```{r model 4c, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4c.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4c <- WAIC
ModComp.4$WAIC[3] <- WAIC4c$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4c <- LOOIC
ModComp.4$LOOIC[3] <- LOOIC4c[3]

# WAIC Detail
WAIC.4c <- data.frame(modID = c('WAIC4c'), model = c('4c'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4c <- data.frame(modID = c('LOOIC4c'), model = c('4c'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4c <- out
```

#### Model 4d
AG/BG ~ time + SOI + sediment + light
```{r model 4d, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4d.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Li = Light) #,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3","beta4", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4d <- WAIC
ModComp.4$WAIC[4] <- WAIC4d$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4d <- LOOIC
ModComp.4$LOOIC[4] <- LOOIC4d[3]

# WAIC Detail
WAIC.4d <- data.frame(modID = c('WAIC4d'), model = c('4d'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4d <- data.frame(modID = c('LOOIC4d'), model = c('4d'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4d <- out
```

#### Model 4e
AG/BG ~ time + quad(SOI)
```{r model 4e, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4e.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype, Li = Light Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4e <- WAIC
ModComp.4$WAIC[5] <- WAIC4e$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4e <- LOOIC
ModComp.4$LOOIC[5] <- LOOIC4e[3]

# WAIC Detail
WAIC.4e <- data.frame(modID = c('WAIC4e'), model = c('4e'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4e <- data.frame(modID = c('LOOIC4e'), model = c('4e'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4e <- out
```

#### Model 4f
AG/BG ~ time + quad(SOI) + Sediment
```{r model 4f, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4f.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype) #, Li = Light Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b", "beta3",  "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4f <- WAIC
ModComp.4$WAIC[6] <- WAIC4f$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4f <- LOOIC
ModComp.4$LOOIC[6] <- LOOIC4f[3]

# WAIC Detail
WAIC.4f <- data.frame(modID = c('WAIC4f'), model = c('4f'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4f <- data.frame(modID = c('LOOIC4f'), model = c('4f'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4f <- out
```

#### Model 4g
AG/BG ~ quad(time) + SOI
```{r model 4g, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4g.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Li = Light Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4g <- WAIC
ModComp.4$WAIC[7] <- WAIC4g$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4g <- LOOIC
ModComp.4$LOOIC[7] <- LOOIC4g[3]

# WAIC Detail
WAIC.4g <- data.frame(modID = c('WAIC4g'), model = c('4g'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4g <- data.frame(modID = c('LOOIC4g'), model = c('4g'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4g <- out
```

#### Model 4h
AG/BG ~ quad(time) + quad(SOI)
```{r model 4h, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_4h.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Li = Light Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, .1, 1), sigO = runif(1, .1, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta1b","beta2", "beta2b",  "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC4h <- WAIC
ModComp.4$WAIC[8] <- WAIC4h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC4h <- LOOIC
ModComp.4$LOOIC[8] <- LOOIC4h[3]

# WAIC Detail
WAIC.4h <- data.frame(modID = c('WAIC4h'), model = c('4h'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.4h <- data.frame(modID = c('LOOIC4h'), model = c('4h'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out4h <- out
```

### Model 4 Comparison
```{r Model 4 comparison, echo = FALSE}
# Clean up work session
stopCluster(cl = cl)
rm(out)

## WAIC ##
# Rank and organize model comparison table
modranks.WAIC <- order(ModComp.4$WAIC)
WAIC.4.full <- rbind(WAIC.4a, WAIC.4b, WAIC.4c, WAIC.4d, WAIC.4e, WAIC.4f, WAIC.4g, WAIC.4h)
comptab.WAIC <- compare(WAIC4a, WAIC4b, WAIC4c, WAIC4d, WAIC4e, WAIC4f, WAIC4g, WAIC4h)
filelist.WAIC <- row.names(comptab.WAIC)

# Calculate comaprison values
for (i in 2:8){
  row = which(WAIC.4.full$modID == filelist.WAIC[i])
  comp = compare(eval(as.name(filelist.WAIC[i])) , eval(as.name(filelist.WAIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  WAIC.4.full$deltaWAIC[row] = comp[1]
  WAIC.4.full$deltaWAIC_se[row] = comp[2]
  WAIC.4.full$P_comp[row] = P_val
}

# organize final table
WAIC.4.full <- WAIC.4.full[modranks.WAIC,]
WAIC.4.full$P_comp[1] = 1
WAIC.4.full$Likelihood = exp(-0.5*WAIC.4.full$deltaWAIC)
WAIC.4.full$Likelihood[WAIC.4.full$P_comp < 0.1] = 0 
sumlik = sum(WAIC.4.full$Likelihood)
WAIC.4.full$WAICwt = WAIC.4.full$Likelihood/sumlik

# round
WAIC.4.full <- cbind(WAIC.4.full[,1:2], round(WAIC.4.full[, 3:9], 3))

## LOOIC ##
# Rank and organize model comparison table
ModComp.4$LOOIC <- as.numeric(ModComp.4$LOOIC)
modranks.LOOIC <- order(ModComp.4$LOOIC)
LOOIC.4.full <- rbind(LOOIC.4a, LOOIC.4b, LOOIC.4c, LOOIC.4d, LOOIC.4e, LOOIC.4f, LOOIC.4g, LOOIC.4h)
comptab.LOOIC <- compare(LOOIC4a, LOOIC4b, LOOIC4c, LOOIC4d, LOOIC4e, LOOIC4f, LOOIC4g, LOOIC4h)
filelist.LOOIC <- row.names(comptab.LOOIC)

# Calculate comparison values
for (i in 2:8){
  row = which(LOOIC.4.full$modID == filelist.LOOIC[i])
  comp = compare(eval(as.name(filelist.LOOIC[i])) , eval(as.name(filelist.LOOIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  LOOIC.4.full$deltaLOOIC[row] = comp[1]
  LOOIC.4.full$deltaLOOIC_se[row] = comp[2]
}

# organize final table
LOOIC.4.full <- LOOIC.4.full[modranks.LOOIC,]
LOOIC.4.full$Likelihood = exp(-0.5*LOOIC.4.full$deltaLOOIC)
LOOIC.4.full$Likelihood[LOOIC.4.full$P_comp < 0.1] = 0 
sumlik = sum(LOOIC.4.full$Likelihood)
LOOIC.4.full$LOOICwt = LOOIC.4.full$Likelihood/sumlik

# round
LOOIC.4.full <- cbind(LOOIC.4.full[,1:2], round(LOOIC.4.full[, 3:8], 3))
```

### Model 4 Comparison tables
WAIC Comparison
```{r model 4 WAIC, echo = FALSE}
DT::datatable(WAIC.4.full)

# write
write.csv(WAIC.4.full, "EG_Mod4_WAIC.csv", row.names = FALSE)
```

LOICC comparison
```{r model 4 LOOIC, echo = FALSE}
DT::datatable(LOOIC.4.full)

# write
write.csv(LOOIC.4.full, "EG_Mod4_LOOIC.csv", row.names = FALSE)
```

#### Model 4 Best model comparison plots
Top three models
```{r Model 4 full model plots }
plot(out4b, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 2))

plot(out4g, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 3))

plot(out4a, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 2))
```

Posteriors only
```{r posteriors only}
plot(out4b, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
plot(out4g, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
plot(out4a, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
```

```{r top models table}
## Model 4b summary stats ##
sum.4b <- add.summary(out4b, c("sig","beta"))
sumstats.4b <- as.data.frame(sum.4b$summaries)
sumstats.4b$Coef <- rownames(sumstats.4b)
sumstats.4b$Model <- "4b"

## Model 4g summary stats ##
sum.4g <- add.summary(out4g, c("sig","beta"))
sumstats.4g <- as.data.frame(sum.4g$summaries)
sumstats.4g$Coef <- rownames(sumstats.4g)
sumstats.4g$Model <- "4g"

## Model 4a summary stats ##
sum.4a <- add.summary(out4a, c("sig","beta"))
sumstats.4a <- as.data.frame(sum.4a$summaries)
sumstats.4a$Coef <- rownames(sumstats.4a)
sumstats.4a$Model <- "4a"

## All Together Now ##
sumstats.4 <- rbind(sumstats.4b, sumstats.4g, sumstats.4a)
rownames(sumstats.4) <- c()
sumstats.4 <- cbind(sumstats.4[, c(13, 12)], round(sumstats.4[, 1:11], 4))

# Change names #
sumstats.4$Coef <- recode(sumstats.4$Coef, sigS = "among site", sigO = "within site", beta1 = "time", beta1b = "time^2", beta2 = "SOI", beta2b = "SOI^2", beta3 = "sediment", beta0 = "intercept")

DT::datatable(sumstats.4)

# Save ##
write.csv(sumstats.4, "EG_Mod4_sumstats.csv", row.names = FALSE)
```

```{r plots?}
ggplot(sumstats.4, aes(color = Model)) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_linerange(aes(Coef, ymin = Lower95, ymax = Upper95), lwd = 1.5, position = position_dodge(width = 1/2)) +
  geom_point(aes(Coef, Median), size = 3, position = position_dodge(width = 1/2)) +
  coord_flip() + 
  scale_y_continuous(breaks = seq(-1, 1, by = 0.25)) +
  labs(x = "Coefficient Name", y = " Coefficient Value +/- CI")
```

### Model 4 Plotting best model
```{r model 4 plotting best model, echo=FALSE}
# Extract best model
best4.WAIC <- paste0(c("out", paste0(WAIC.4.full[1,2])), collapse = "")
best4.LOOIC <- paste0(c("out", paste0(LOOIC.4.full[1,2])), collapse = "")

# Test for difference in best model between WAIC and LOOIC. If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model
ifelse(all.equal(best4.WAIC, best4.LOOIC) == TRUE, best2 <- eval(best4.WAIC), best2 <- eval(best4.LOOIC))

# Extract MCMC values
post <- rbind(out4b$mcmc[[1]], out4b$mcmc[[2]])

# Loop over number of cores
for (i in 3:nc){
  post <- rbind(post, out4b$mcmc[[i]])
}

# Calculate summary stats
reps <- dim(post)[1]
sumout <- add.summary(out4b, c("sig","beta"))
sumstats <- sumout$summaries
vn <- row.names(sumstats)

# Diagnostic plots
plot(out4b, c('trace', 'histogram'), vars=c("sig","beta"))

# Create dataframes for plotting fixed effects: assume Model4b
mind <- min(Dayindx)
maxd <- max(Dayindx)
Julday <- numeric(length = length(seq(mind:maxd)))
Predict <- numeric(length = length(seq(mind:maxd)))
Lwr <- numeric(length = length(seq(mind:maxd)))
Upr <- numeric(length = length(seq(mind:maxd)))
sig <- post[,which(vn == 'sigO')]
bt0 <- post[,which(vn == 'beta0')]
bt1 <- post[,which(vn == 'beta1')]
bt2 <- post[,which(vn == 'beta2')]

for (d in mind:maxd){
  Julday[d] = d - 1 + Minday
  Mu = bt0 + bt1*d
  Predict[d] = mean(exp(Mu + sig^2/2))
  Lwr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .975))
} 

dfDay = data.frame(Julianday = Julday, Mean = Predict, Lwr = Lwr, Upr = Upr)
dfData = data.frame(x = Julianday, y = Obs)

p1 <- ggplot(dfDay, aes(x = Julianday, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  # geom_point(data = dfData, aes(x=x, y=y))+
  xlab('Julian Day') + 
  ylab(bquote('Predicted AG/BG mass +/- 95% CI ' ~(g/m^2))) +
  theme(text = element_text(size = 12), axis.ticks = element_line(size = 2), legend.position = "none")

# save plot
ggsave("Mod4b_time.png", p1, dpi = 400)

Ottvals <- seq(min(Ottindx), max(Ottindx), length.out = 100)
Predict <- numeric(length = 100)
Lwr <- numeric(length = 100)
Upr <- numeric(length = 100)

for (o in 1:100){
  Mu <- bt0 + bt1*MeanDay  + bt2*Ottvals[o]
  Predict[o] <- mean(exp(Mu + sig^2/2))
  Lwr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .975))
}

dfOtt = data.frame(OtterIndex = Ottvals, Mean = Predict, Lwr = Lwr, Upr = Upr)

p2 <- ggplot(dfOtt, aes(x = OtterIndex, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  xlab('Sea Otter Index') + 
  ylab(bquote('Mean Pred AG/BG mass +/- 95% CI ' ~(g/m^2))) +
  theme(text = element_text(size = 12), axis.ticks = element_line(size = 2), legend.position = "none")

# save plot
ggsave("Mod4b_SOI.png", p2, dpi = 400)

plot_grid(p1, p2, nrow = 2, ncol = 1)
```

### Model 5 - Epiphyte load (grams epiphytes to grams eelgrass)
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, sediment type, light attenuation, and grazer load may effect piephyte load on eelgrass. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900.

```{r Model 5 set up, echo=FALSE}
# Dependent observed variable: this should be whatever numeric variable you wish to analyze 
Obs <- as.numeric(tran.dat$epimass_shootmass)
Obs[Obs == 0] <- 0.0001 # Can't have 0s so convert 0 to very small value

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Sedtype <- as.numeric(tran.dat$sed1_no)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Light <- as.numeric(tran.dat$light_attenu)[ii]
Graz <- as.numeric(log(tran.dat$grazmass_shootmass + 0.0001)) [ii] # add 0.0001 to have non Inf values.
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting attributes of data
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.5 <- data.frame(Model = c("Model_5a","Model_5b","Model_5c","Model_5d","Model_5e","Model_5f","Model_5g", "Model_5h", "Model5i", "Model5j", "Model5k", "Model5l"), WAIC = numeric(length = 12), LOOIC = numeric(length = 12))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 5a
epi ~ time
```{r model 5a, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5a.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx) # Ott = Ottindx, Sed = Sedtype, Li = Light, Grz = Graz, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta1","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5a <- WAIC
ModComp.5$WAIC[1] <- WAIC5a$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5a <- LOOIC
ModComp.5$LOOIC[1] <- LOOIC5a[3]

# WAIC Detail
WAIC.5a <- data.frame(modID = c('WAIC5a'), model = c('5a'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5a <- data.frame(modID = c('LOOIC5a'), model = c('5a'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5a <- out
```

#### Model 5b
epi ~ time + SOI
```{r model 5b, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5b.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) # , Sed = Sedtype, Li = Light, Grz = Graz, Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5b <- WAIC
ModComp.5$WAIC[2] <- WAIC5b$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5b <- LOOIC
ModComp.5$LOOIC[2] <- LOOIC5b[3]

# WAIC Detail
WAIC.5b <- data.frame(modID = c('WAIC5b'), model = c('5b'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5b <- data.frame(modID = c('LOOIC5b'), model = c('5b'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5b <- out
```

#### Model 5c
epi ~ Graz
```{r model 5c, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5c.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Grz = Graz) #Day = Dayindx, Ott = Ottindx , Sed = Sedtype, Li = Light, , Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta5","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5c <- WAIC
ModComp.5$WAIC[3] <- WAIC5c$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5c <- LOOIC
ModComp.5$LOOIC[3] <- LOOIC5c[3]

# WAIC Detail
WAIC.5c <- data.frame(modID = c('WAIC5c'), model = c('5c'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5c <- data.frame(modID = c('LOOIC5c'), model = c('5c'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5c <- out
```

#### Model 5d
epi ~ time + Graz
```{r model 5d, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5d.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Grz = Graz) #, Ott = Ottindx , Sed = Sedtype, Li = Light, , Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta5","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5d <- WAIC
ModComp.5$WAIC[4] <- WAIC5d$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5d <- LOOIC
ModComp.5$LOOIC[4] <- LOOIC5d[3]

# WAIC Detail
WAIC.5d <- data.frame(modID = c('WAIC5d'), model = c('5d'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5d <- data.frame(modID = c('LOOIC5d'), model = c('5d'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5d <- out
```

#### Model 5e
epi ~ SOI + Graz
```{r model 5e, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5e.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Ott = Ottindx, Grz = Graz) #,Day = Dayindx , Sed = Sedtype, Li = Light, , Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta2","beta5","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5e <- WAIC
ModComp.5$WAIC[5] <- WAIC5e$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5e <- LOOIC
ModComp.5$LOOIC[5] <- LOOIC5e[3]

# WAIC Detail
WAIC.5e <- data.frame(modID = c('WAIC5e'), model = c('5e'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5e <- data.frame(modID = c('LOOIC5e'), model = c('5e'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5e <- out
```

#### Model 5f
epi ~ time + SOI + Graz
```{r model 5f, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5f.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Grz = Graz) #, , Sed = Sedtype, Li = Light, , Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta1", "beta2","beta5","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5f <- WAIC
ModComp.5$WAIC[6] <- WAIC5f$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5f <- LOOIC
ModComp.5$LOOIC[6] <- LOOIC5f[3]

# WAIC Detail
WAIC.5f <- data.frame(modID = c('WAIC5f'), model = c('5f'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5f <- data.frame(modID = c('LOOIC5f'), model = c('5f'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5f <- out
```

#### Model 5g
epi ~ time + SOI + Sed + Graz
```{r model 5g, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5g.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Grz = Graz) #, , , Li = Light, , Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3","beta5","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5g <- WAIC
ModComp.5$WAIC[7] <- WAIC5g$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5g <- LOOIC
ModComp.5$LOOIC[7] <- LOOIC5g[3]

# WAIC Detail
WAIC.5g <- data.frame(modID = c('WAIC5g'), model = c('5g'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5g <- data.frame(modID = c('LOOIC5g'), model = c('5g'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5g <- out
```

#### Model 5h
epi ~ time + SOI + Sed + Light + Graz
```{r model 5h, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5h.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Sed = Sedtype, Li = Light, Grz = Graz) #, , , , , Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta3","beta4","beta5","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5h <- WAIC
ModComp.5$WAIC[8] <- WAIC5h$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5h <- LOOIC
ModComp.5$LOOIC[8] <- LOOIC5h[3]

# WAIC Detail
WAIC.5h <- data.frame(modID = c('WAIC5h'), model = c('5h'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5h <- data.frame(modID = c('LOOIC5h'), model = c('5h'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5h <- out
```

#### Model 5i
epi ~ time + quad(SOI)
```{r model 5i, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5i.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx) #, Sed = Sedtype, Li = Light, Grz = Graz) Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5i <- WAIC
ModComp.5$WAIC[9] <- WAIC5i$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5i <- LOOIC
ModComp.5$LOOIC[9] <- LOOIC5i[3]

# WAIC Detail
WAIC.5i <- data.frame(modID = c('WAIC5i'), model = c('5i'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5i <- data.frame(modID = c('LOOIC5i'), model = c('5i'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5i <- out
```

#### Model 5j
epi ~ time + quad(SOI) + Graz
```{r model 5j, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5j.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Grz = Graz) #, Sed = Sedtype, Li = Light,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","beta5", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5j <- WAIC
ModComp.5$WAIC[10] <- WAIC5j$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5j <- LOOIC
ModComp.5$LOOIC[10] <- LOOIC5j[3]

# WAIC Detail
WAIC.5j <- data.frame(modID = c('WAIC5j'), model = c('5j'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5j <- data.frame(modID = c('LOOIC5j'), model = c('5j'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5j <- out
```

#### Model 5k
epi ~ time + quad(SOI) + quad(Graz)
```{r model 5l, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5k.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Day = Dayindx, Ott = Ottindx, Grz = Graz) #, Sed = Sedtype, Li = Light,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta1","beta2","beta2b","beta5","beta5b", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5k <- WAIC
ModComp.5$WAIC[11] <- WAIC5k$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5k <- LOOIC
ModComp.5$LOOIC[11] <- LOOIC5k[3]

# WAIC Detail
WAIC.5k <- data.frame(modID = c('WAIC5k'), model = c('5k'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5k <- data.frame(modID = c('LOOIC5k'), model = c('5k'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5k <- out
```

#### Model 5l
epi ~ quad(SOI) + Graz
```{r model 5l, echo=FALSE}
# Call up JAGS file
jagsfile <- 'JAGS/Eelgrass_5l.jags'
# savename='EelgrassM1a_Results.Rdata'

jags.data <- list(Nsites = Nsites, Nobs = Nobs, Obs = Obs, Site = Sitenum, Ott = Ottindx, Grz = Graz) #, Sed = Sedtype, Li = Light,  Nquads = Nquads, Quad = Quad

inits <- function() list(sigS = runif(1, 0, 1), sigO = runif(1, 0, 1)) 

params <- c("sigS","sigO","beta0","beta2","beta2b","beta5", "eps","loglik") 

# Call JAGS from R 
out <- run.jags(data = jags.data, 
                inits = inits, 
                monitor = params, 
                model = jagsfile, 
                n.chains = nc, 
                thin = nt, 
                sample = nsamples, 
                burnin = nb,
                method="rjparallel", cl=cl)

post = rbind(out$mcmc[[1]], out$mcmc[[2]])
for (i in 3:nc){
  post = rbind(post, out$mcmc[[i]])
}

# Calculate WAIC
mc_ll <- post[,paste0("loglik[",1:Nobs,"]")]
WAIC <- waic(mc_ll)
WAIC5l <- WAIC
ModComp.5$WAIC[12] <- WAIC5l$waic

# Calculate LOOIC
LOOIC <- loo(mc_ll)
LOOIC5l <- LOOIC
ModComp.5$LOOIC[12] <- LOOIC5l[3]

# WAIC Detail
WAIC.5l <- data.frame(modID = c('WAIC5l'), model = c('5l'), WAIC = WAIC$waic, WAIC_se = WAIC$se_waic, deltaWAIC = c(0), deltaWAIC_se = c(0), P_comp = c(0))

# LOOIC Detail
LOOIC.5l <- data.frame(modID = c('LOOIC5l'), model = c('5l'), LOOIC$looic, LOOIC_se = LOOIC$se_looic, deltaLOOIC = c(0), deltaLOOIC_se = c(0))

out5l <- out
```

### Model 5 Comparison
```{r Model 5 comparison, echo = FALSE}
# Clean up work session
stopCluster(cl = cl)
rm(out)

## WAIC ##
# Rank and organize model comparison table
modranks.WAIC <- order(ModComp.5$WAIC)
WAIC.5.full <- rbind(WAIC.5a, WAIC.5b, WAIC.5c, WAIC.5d, WAIC.5e, WAIC.5f, WAIC.5g, WAIC.5h, WAIC.5i, WAIC.5j, WAIC.5k, WAIC.5l)
comptab.WAIC <- compare(WAIC5a, WAIC5b, WAIC5c, WAIC5d, WAIC5e, WAIC5f, WAIC5g, WAIC5h, WAIC5i, WAIC5j, WAIC5k, WAIC5l)
filelist.WAIC <- row.names(comptab.WAIC)

for (i in 2:12){
  row = which(WAIC.5.full$modID == filelist.WAIC[i])
  comp = compare(eval(as.name(filelist.WAIC[i])) , eval(as.name(filelist.WAIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  WAIC.5.full$deltaWAIC[row] = comp[1]
  WAIC.5.full$deltaWAIC_se[row] = comp[2]
  WAIC.5.full$P_comp[row] = P_val
}

WAIC.5.full <- WAIC.5.full[modranks.WAIC,]
WAIC.5.full$P_comp[1] = 1
WAIC.5.full$Likelihood = exp(-0.5*WAIC.5.full$deltaWAIC)
WAIC.5.full$Likelihood[WAIC.5.full$P_comp < 0.1] = 0 
sumlik = sum(WAIC.5.full$Likelihood)
WAIC.5.full$WAICwt = WAIC.5.full$Likelihood/sumlik

# round
WAIC.5.full <- cbind(WAIC.5.full[,1:2], round(WAIC.5.full[, 3:9], 3))

## LOOIC ##
ModComp.5$LOOIC <- as.numeric(ModComp.5$LOOIC)
modranks.LOOIC <- order(ModComp.5$LOOIC)
LOOIC.5.full <- rbind(LOOIC.5a, LOOIC.5b, LOOIC.5c, LOOIC.5d, LOOIC.5e, LOOIC.5f, LOOIC.5g, LOOIC.5h, LOOIC.5i, LOOIC.5k, LOOIC.5k, LOOIC.5l)
comptab.LOOIC <- compare(LOOIC5a, LOOIC5b, LOOIC5c, LOOIC5d, LOOIC5e, LOOIC5f, LOOIC5g, LOOIC5h, LOOIC5i, LOOIC5k, LOOIC5k, LOOIC5l)
filelist.LOOIC <- row.names(comptab.LOOIC)

for (i in 2:12){
  row = which(LOOIC.5.full$modID == filelist.LOOIC[i])
  comp = compare(eval(as.name(filelist.LOOIC[i])) , eval(as.name(filelist.LOOIC[1])) )
  Z_score = comp[1]/comp[2]
  P_val = 1-pnorm(Z_score)
  LOOIC.5.full$deltaLOOIC[row] = comp[1]
  LOOIC.5.full$deltaLOOIC_se[row] = comp[2]
}

LOOIC.5.full <- LOOIC.5.full[modranks.LOOIC,]
LOOIC.5.full$Likelihood = exp(-0.5*LOOIC.5.full$deltaLOOIC)
LOOIC.5.full$Likelihood[LOOIC.5.full$P_comp < 0.1] = 0 
sumlik = sum(LOOIC.5.full$Likelihood)
LOOIC.5.full$LOOICwt = LOOIC.5.full$Likelihood/sumlik

# round
LOOIC.5.full <- cbind(LOOIC.5.full[,1:2], round(LOOIC.5.full[, 3:8], 3))
```

### Model 5 Best model comparison tables
WAIC Comparison
```{r model 5 WAIC, echo = FALSE}
DT::datatable(WAIC.5.full)

# write
write.csv(WAIC.5.full, "EG_Mod5_WAIC.csv", row.names = FALSE)
```

LOICC comparison
```{r model 5 LOOIC, echo = FALSE}
DT::datatable(LOOIC.5.full)

# write
write.csv(LOOIC.5.full, "EG_Mod5_LOOIC.csv", row.names = FALSE)
```

#### Model 5 Best model comparison plots
Top three models
```{r Model 5 full model plots }
plot(out5f, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 3))

plot(out5e, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 3))

plot(out5d, c('trace', 'histogram'), vars = c("sig", "beta"), layout = c(4, 3))
```

Posteriors only
```{r posteriors only}
plot(out5f, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
plot(out5e, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
plot(out5d, "histogram", vars = c("sig", "beta"), layout = c(1, 6))
```

```{r top models table}
## Model 5f summary stats ##
sum.5f <- add.summary(out5f, c("sig","beta"))
sumstats.5f <- as.data.frame(sum.5f$summaries)
sumstats.5f$Coef <- rownames(sumstats.5f)
sumstats.5f$Model <- "5f"

## Model 5e summary stats ##
sum.5e <- add.summary(out5e, c("sig","beta"))
sumstats.5e <- as.data.frame(sum.5e$summaries)
sumstats.5e$Coef <- rownames(sumstats.5e)
sumstats.5e$Model <- "5e"

## Model 5d summary stats ##
sum.5d <- add.summary(out5d, c("sig","beta"))
sumstats.5d <- as.data.frame(sum.5d$summaries)
sumstats.5d$Coef <- rownames(sumstats.5d)
sumstats.5d$Model <- "5d"

## All Together Now ##
sumstats.5 <- rbind(sumstats.5f, sumstats.5e, sumstats.5d)
rownames(sumstats.5) <- c()
sumstats.5 <- cbind(sumstats.5[, c(13, 12)], round(sumstats.5[, 1:11], 4))

# Change names #
sumstats.5$Coef <- recode(sumstats.5$Coef, sigS = "among site", sigO = "within site", beta1 = "time", beta1b = "time^2", beta2 = "SOI", beta2b = "SOI^2", beta3 = "sediment", beta5 = "grazer", beta0 = "intercept")

DT::datatable(sumstats.5)

# Save ##
write.csv(sumstats.5, "EG_Mod5_sumstats.csv", row.names = FALSE)
```

```{r plots?}
ggplot(sumstats.5, aes(color = Model)) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_linerange(aes(Coef, ymin = Lower95, ymax = Upper95), lwd = 1.5, position = position_dodge(width = 1/2)) +
  geom_point(aes(Coef, Median), size = 3, position = position_dodge(width = 1/2)) +
  coord_flip() + 
  scale_y_continuous(breaks = seq(-6.5, 2, by = 0.5)) +
  labs(x = "Coefficient Name", y = " Coefficient Value +/- CI")
```

### Model 5 Plotting best model
THIS IS NOT OPERATIONAL AT THE MOMENT, MODEL MAY NEED TO BE EXAMINED MORE CAREFULLY
```{r model 5 plotting best model, echo=FALSE}
# Extract best model
best5.WAIC <- paste0(c("out", paste0(WAIC.5.full[1,2])), collapse = "")
best5.LOOIC <- paste0(c("out", paste0(LOOIC.5.full[1,2])), collapse = "")

# Test for difference in best model between WAIC and LOOIC. If both best model agree then use the best WAIC model, if they dissagree use lest LOOIC model
ifelse(all.equal(best5.WAIC, best5.LOOIC) == TRUE, best2 <- eval(best5.WAIC), best2 <- eval(best5.LOOIC))

# Extract MCMC values
post <- rbind(out5f$mcmc[[1]], out5f$mcmc[[2]])

# Loop over number of cores
for (i in 3:nc){
  post <- rbind(post, out5f$mcmc[[i]])
}

# Calculate summary stats
reps <- dim(post)[1]
sumout <- add.summary(out5f, c("sig","beta"))
sumstats <- sumout$summaries
vn <- row.names(sumstats)

# Diagnostic plots
plot(out5f, c('trace', 'histogram'), vars=c("sig","beta"))

# Create dataframes for plotting fixed effects: assume Model5f
mind <- min(Dayindx)
maxd <- max(Dayindx)
Julday <- numeric(length = length(seq(mind:maxd)))
Predict <- numeric(length = length(seq(mind:maxd)))
Lwr <- numeric(length = length(seq(mind:maxd)))
Upr <- numeric(length = length(seq(mind:maxd)))
sig <- post[,which(vn == 'sigO')]
bt0 <- post[,which(vn == 'beta0')]
bt1 <- post[,which(vn == 'beta1')]
bt2 <- post[,which(vn == 'beta2')]
bt5 <- post[,which(vn == 'beta5')]

for (d in mind:maxd){
  Julday[d] = d - 1 + Minday
  Mu = bt0 + bt1*d 
  Predict[d] = mean(exp(Mu + sig^2/2))
  Lwr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[d] = as.numeric(quantile(exp(Mu + sig^2/2), .975))
} 

dfDay = data.frame(Julianday = Julday, Mean = Predict, Lwr = Lwr, Upr = Upr)
dfData = data.frame(x = Julianday, y = Obs)

p1 <- ggplot(dfDay, aes(x = Julianday, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  # geom_point(data = dfData, aes(x=x, y=y))+
  xlab('Julian Day') + 
  ylab(bquote('Mean Pred epiphyte load' ~(g/g))) +
  theme(legend.position = "none")

Ottvals <- seq(min(Ottindx), max(Ottindx), length.out = 100)
Predict <- numeric(length = 100)
Lwr <- numeric(length = 100)
Upr <- numeric(length = 100)

for (o in 1:100){
  Mu <- bt0 + bt1*MeanDay  + bt2*Ottvals[o]
  Predict[o] <- mean(exp(Mu + sig^2/2))
  Lwr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[o] <- as.numeric(quantile(exp(Mu + sig^2/2), .975))
}

dfOtt = data.frame(OtterIndex = Ottvals, Mean = Predict, Lwr = Lwr, Upr = Upr)

p2 <- ggplot(dfOtt, aes(x = OtterIndex, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  xlab('Sea Otter Index') + 
  ylab(bquote('Predicted Epiphyte load' ~(g/g))) +
  theme(legend.position = "none")

Grzvals <- seq(min(exp(Graz)), max(exp(Graz)), length.out = 100)
Predict <- numeric(length = 100)
Lwr <- numeric(length = 100)
Upr <- numeric(length = 100)

for (g in 1:100){
  Mu <- bt0 + bt1*MeanDay  + bt2*mean(Ottindx) + exp(bt5)*Grzvals[g]
  Predict[g] <- mean(exp(Mu + sig^2/2))
  Lwr[g] <- as.numeric(quantile(exp(Mu + sig^2/2), .025))
  Upr[g] <- as.numeric(quantile(exp(Mu + sig^2/2), .975))
}


dfGrz = data.frame(GrazLoad = Grzvals, Mean = Predict, Lwr = Lwr, Upr = Upr)

## this does not seem right, grazer effect should be negative i think seem univariate plot log(epi) v log(grazer)
p3 <- ggplot(dfGrz, aes(x = GrazLoad, y = Mean)) + 
  geom_ribbon(aes(ymin = Lwr, ymax = Upr), alpha = 0.2) + 
  geom_line(size = 1) +
  xlab(bquote('Grazer load' ~(g/g))) + 
  ylab(bquote('Predicted Epiphyte load' ~(g/g))) +
  theme(legend.position = "none")

plot_grid(p1, p2, nrow = 2, ncol = 1)
```

### Model 6 - Grazer load (grams epiphytes to grams eelgrass)
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, epiphyte load, crab biomass, and fish biomass may affect grazer load on eelgrass. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900.

```{r Model 6 set up, echo=FALSE}
# Dependent observed variable: this should be whatever numeric variable you wish to analyze 
Obs <- as.numeric(tran.dat$grazmass_shootmass)
Obs[Obs == 0] <- 0.0001 # Can't have 0s so convert 0 to very small value

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Epi <- as.numeric(log(tran.dat$epimass_shootmass + 0.0001)) [ii] # add 0.0001 to have non Inf values.
CrabMass <- as.numeric(crab.string$mass) ##### many 0s and/or log normalness to head with
CrabCnt <- as.numeric(crab.string$count) ##### many 0s and/or log normalness to head with
RockMass <- as.numeric(crab.rock$mass) ##### many 0s and/or log normalness to head with
RockCnt <- as.numeric(crab.rock$count) ##### many 0s and/or log normalness to head with
Fish <- ## INSERT FISH DATA HERE - BUT THAT MIGHT BE A WHILE ##
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting attributes of data
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.6 <- data.frame(Model = c("Model_6a","Model_6b","Model_6c","Model_6d","Model_6e","Model_6f","Model_6g", "Model_6h", "Model6i"), WAIC = numeric(length = 12), LOOIC = numeric(length = 12))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 6a
INSERT MODELS HERE

### Model 6 Comparison
INSERT COMPARISONS HERE

### Model 6 Best model comparison table
INSERT COMPARISON TABLES HERE

#### Model 6 Best model comparison plots
INSERT BEST MODEL PLOTS

### Model 6 Plotting best model
INSERT BEST MODEL PLOT

### Model 7 - Crab biomass
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, grazer load, and fish biomass may affect crab biomass at our sites. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900.

There are 9 instances of no crabs nad therefore no mass out of 63 stings. Should we consider a two stage model to deal with zeros??

We may also want to model the responce of just cancer/rock crabs, see ObsRK
```{r Model 7 set up, echo=FALSE}
# Dependent observed variable: this should be whatever numeric variable you wish to analyze 
Obs <- as.numeric(crab.string$mass)
ObsRK <- as.numeric(crab.rock$mass)

# select only oberved variables that are not NA
ii <- which(!is.na(Obs))
Obs <- Obs[ii]

# Variables to use as independent or identifier variables
Ottindx <- as.numeric(tran.dat$sea_otter_index)[ii]
Julianday <- as.numeric(tran.dat$date_julian)[ii]
Graz <- as.numeric(log(tran.dat$grazmass_shootmass + 0.0001)) [ii] # add 0.0001 to have non Inf values.
Fish <- ## INSERT FISH DATA HERE - BUT THAT MIGHT BE A WHILE ##
Sitetxt <- tran.dat$site[ii]
Quad <- as.numeric(tran.dat$quadrat)[ii]

# Extracting attributes of data
Sitelist <- unique(Sitetxt)
Sitenum <- as.numeric(as.factor(Sitetxt))
Sites <- seq(1, max(Sitenum))
Nsites <- max(Sitenum)
Nquads <- max(Quad)
Nobs <- length(Obs)
Minday <- min(Julianday)
Dayindx <- Julianday - Minday + 1
MeanDay <- round(mean(Dayindx),0)

# Model comparison data frame
ModComp.7 <- data.frame(Model = c("Model_7a","Model_7b","Model_7c","Model_7d","Model_7e","Model_7f","Model_7g", "Model_7h", "Model7i"), WAIC = numeric(length = 12), LOOIC = numeric(length = 12))

# Set up for parralel computing
cores <- detectCores()
ncore <- min(20, cores-1)

# Set JAGS params for running
nsamples <- 2900
nt <- 20
nb <- 7000
nc <- ncore

# For parallel (comment out for serial)
cl <- makeCluster(ncore)
```

#### Model 7a
INSERT MODELS HERE

### Model 7 Comparison
INSERT COMPARISONS HERE

### Model 7 Best model comparison table
INSERT COMPARISON TABLES HERE

#### Model 7 Best model comparison plots
INSERT BEST MODEL PLOTS

### Model 7 Plotting best model
INSERT BEST MODEL PLOT

### Model 8 - Fish biomass
Response  - log normally distributed. We hypothesise that time (as julian day), sea otter index, shoot dnesity, aboveground biomass, grazer load, and crab biomass may affect fish biomass at our sites. Note that the number of samples (nsamples) will need to adjusted to suit the number of cores running on your machine so that the resulting analysis results in >= 20,000 samples. For example if you have 8 cores you can run analysis on 7 cores so nsamples should = 2900

Given the structure of this data we may need to modle this differnetly
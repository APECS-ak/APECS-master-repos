---
title: "Exploration of sediment influence on seagrass"
author: "Tiff Stephens"
#date: "1/6/2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
library(dplyr); library(tidyr); library(plyr); library(reshape2); library(lubridate); library(ggplot2); library(DT); library(leaflet); library(htmlwidgets); library(htmltools); library(shiny); library(mapview); library(sp); library(sf); library(knitr); library(cowplot); library(ggpmisc)
theme_set(theme_classic())
theme_set(theme_cowplot(font_size=12)) # default fontsize doesn't work well for online viewing
```


<br><br>

#### The intention of this .Rmd script is to explore how sediment type (primary and secondary classifications) influences various variables that we measured in Summer 2017. The sediment type data presented here is qualitative, with sediment type classified as 1 of 10 types (1:10 :: fine:big). 
<br><br>

Outline

* 1: Identify and import necessary data
* 2: Tidy and reshape data into complimentary structures
* 3: Join all prepared dataframes together into one working dataframe
* 4: Map general sediment trends
* 5: Regressions of sediment and various dependent variables
     + Aboveground biomass
     + Belowground biomass
     + Epiphyte biomass
     + Pits * belowground biomass

<br><br>

General findings

* Sediment types show a north-south trend, or sea otter trend. Sediments in the north (or otter central) have finer sediments than sites in the south (no otters). This could be natural geographic variation (either due to geology or hydrodynamics) or could be a result of long-term sea otter colonization (if sea otters increase seagrass density, thus particle entrapment). It could also reflect human error, in that we selected more sheltered sites in the north. 
* Significant interactions with aboveground biomass do not appear to exist. 
* Significant interactions with belowground biomass exist in some of the regressions (positively correlated). I chose to standardize the rhizome biomass by length (i.e. g per cm), and then multiplied this metric by shoot density to obtain an area metric for area. Relationships are slightly stronger when belowground biomass is presented as mass per cm of rhizome, not per area.
* Significant interactions exist between sediments and epiphyte biomass (negatively correlated). Hmm. Nutrient flux potential due to sediment pore size (cool idea)? An artefact of hydrology (i.e. larger grain size could be indicative of more flow, more flow could rip away epiphytes? Thoughts. 
* Pits * belowground biomass: there is interaction with outside pit number (negatively correlated)...this could be coincidence; interaction only exists when zero values are exluded from analysis. 

***

<br><br><br><br>




#### 1. Importing data: we need the sediment_pit, biometrics, and transect dataframes from the seagrass sites. Also throw in the coordinate info and the sea otter index. All of these cleaned files are found in the GitHub repositry.

```{r, tidy = TRUE}
df.sedpit <- read.csv("https://raw.githubusercontent.com/APECS-ak/APECS-master-repos/master/ALL_DATA/seagrass_seaotter_pit_sediment_2017_CLEAN.csv", stringsAsFactors = FALSE, header = TRUE)

df.bio <- read.csv("https://raw.githubusercontent.com/APECS-ak/APECS-master-repos/master/ALL_DATA/seagrass_biometrics_CLEAN.csv", stringsAsFactors = FALSE, header = TRUE)

df.trans <- read.csv("https://raw.githubusercontent.com/APECS-ak/APECS-master-repos/master/ALL_DATA/seagrass_transect_2017_RAW.csv", stringsAsFactors = FALSE, header = TRUE)

df.coords <- read.csv("https://raw.githubusercontent.com/APECS-ak/APECS-master-repos/master/ALL_DATA/sites_coordinates.csv", stringsAsFactors = FALSE, header = TRUE)

df.soi <- read.csv("https://raw.githubusercontent.com/APECS-ak/APECS-master-repos/master/ALL_DATA/sea_otter_impact_index_2017.csv", stringsAsFactors = FALSE, header = TRUE)
```
<br><br><br><br>


***


#### 2. Tidy: The next steps are to look at each imported DF, tidy them up, reshape them for the intended analyses, and join all reshaped DFs into one large DF (i.e. 'df.all'). All packages used are libraried at the top of this script. The sript echoed in this .html file but can be accessed in the .Rmd file. 
```{r, include = FALSE} 
### 1. Tidy: delete unwanted variables from each dataframe to reduce clutter
```

```{r, include = FALSE}
str(df.sedpit)
na.omit(df.sedpit)

# don't need these columns
df.sedpit <- within(df.sedpit, rm(X)) # odd extra first column
df.sedpit <- within(df.sedpit, rm(sed1_type)) # redundant with the numeric values
df.sedpit <- within(df.sedpit, rm(sed2_type)) # redundant with the numeric values
df.sedpit <- within(df.sedpit, rm(field_collector)) # who cares for this
df.sedpit <- within(df.sedpit, rm(trans_m)) # don't need to binning factors
```

```{r, include = FALSE}
str(df.trans)
na.omit(df.trans)

# don't need these columns
df.trans <- within(df.trans, rm(primary_observer))
df.trans <- within(df.trans, rm(secondary_observer))
df.trans <- within(df.trans, rm(start_time))
df.trans <- within(df.trans, rm(end_time))
df.trans <- within(df.trans, rm(notes))
str(df.trans)

# convert everything to meter-squared values
df.trans <- df.trans %>%
  mutate(algae_cover_m2 = macroalgae_cover_0.25msq * 1, na.rm = TRUE) %>%
  mutate(epiphyte_cover_m2 = diatom_cover_0.25msq * 1, na.rm = TRUE) %>%
  mutate(seagrass_count_m2 = eelgrass_shoots_0.25msq * 4, na.rm = TRUE) %>%
  mutate(flower_count_m2 = flowering_shoots_0.25msq * 4, na.rm = TRUE) %>%
  select(-na.rm, -macroalgae_cover_0.25msq, -diatom_cover_0.25msq, -eelgrass_shoots_0.25msq, -flowering_shoots_0.25msq)
str(df.trans)
```

```{r, include = FALSE}
str(df.bio)
na.omit(df.bio)

# change column name for consistency with other DFs
colnames(df.bio)[which(names(df.bio) == "collection_date")] <- "date"


# so many obvious unwanted variables in the df for desired analysis; start by removing those
colnames(df.bio) # find which columns to delete in bulk (don't need grazers + epiphytes)
df.bio <- df.bio[, -c(40:71)] # delete columns (grazers + epiphytes)
df.bio <- within(df.bio, rm(rhi_mass_fw))
df.bio <- within(df.bio, rm(shoot_mass_fw))
colnames(df.bio) # recheck column names for accuracy (last should be "shoot_foil_dw")


# need to calculate the weights of shoots + rhizomes + epiphytes
df.bio <- df.bio %>% 
  mutate(epiphyte_mass_dw = pad_epiphyte_mass_g - pad_mass_g) %>%
  mutate(rhi_mass_dw = rhi_foil_dw_g - rhi_foil) %>%
  mutate(shoot_mass_dw = shoot_foil_dw - shoot_foil)

# delete derivitive weights not necessary for analysis
df.bio <- df.bio %>% 
  select(-pad_epiphyte_mass_g, -pad_mass_g) %>% #pads
  select(-rhi_foil_dw_g, -rhi_foil, -shoot_foil, -shoot_foil_dw) #seagrass
colnames(df.bio)


### Now we need to handle all the leaves. For expected analyses, leaf width/length/area might not matter but it will be interesting to look, anyway. 

## LEAF AREA, FIRST
# calculate the leaf area (cm^2) per blade per plant
df.bio <- df.bio %>% 
  mutate(leaf_area1 = leaf_length1 * leaf_width1, na.rm = TRUE) %>%
  mutate(leaf_area2 = leaf_length2 * leaf_width2, na.rm = TRUE) %>%
  mutate(leaf_area3 = leaf_length3 * leaf_width3, na.rm = TRUE) %>%
  mutate(leaf_area4 = leaf_length4 * leaf_width4, na.rm = TRUE) %>%
  mutate(leaf_area5 = leaf_length5 * leaf_width5, na.rm = TRUE) %>%
  mutate(leaf_area6 = leaf_length6 * leaf_width6, na.rm = TRUE) %>%
  mutate(leaf_area7 = leaf_length7 * leaf_width7, na.rm = TRUE) %>%
  mutate(leaf_area8 = leaf_length8 * leaf_width8, na.rm = TRUE) %>%
  mutate(leaf_area9 = leaf_length9 * leaf_width9, na.rm = TRUE) %>%
  mutate(leaf_area10 = leaf_length10 * leaf_width10, na.rm = TRUE)

# mean leaf area per blade
df.bio <- mutate(df.bio, mean_leaf_area_perblade = rowMeans(select(df.bio, starts_with("leaf_area")), na.rm = TRUE))

# calculate total leaf area per plant (there is no biomass data per blade so need to combine all blades)
#df.bio$tot_leaf_area <- rowSums(df.bio[,c("leaf_area1", "leaf_area2", "leaf_area3", "leaf_area4", "leaf_area5", "leaf_area6", "leaf_area7", "leaf_area8", "leaf_area9", "leaf_area10")], na.rm = TRUE)

# total leaf area per plant
df.bio <- mutate(df.bio, tot_leaf_area_perplant = rowSums(select(df.bio, starts_with("leaf_area")), na.rm = TRUE))

# after all of that, we no longer need areas for individual blades...
colnames(df.bio) # find which columns to delete in bulk
df.bio <- df.bio[, -c(35:45)] 



## LEAF LENGTH, SECOND
# mean leaf length per plant (or mean canopy height)
df.bio <- mutate(df.bio, mean_leaf_length_perplant = rowMeans(select(df.bio, starts_with("leaf_length")), na.rm = TRUE))

# max leaf length per plant
colnames(df.bio)
df.bio$max_leaf_length_perplant = apply(df.bio[, 12:21], 1, max, na.rm = TRUE) # ignore warning messages

# after all of that, we no longer need lengths for individual blades...
colnames(df.bio) # find which columns to delete in bulk
df.bio <- df.bio[, -c(12:21)] # delete columns



## LEAF WIDTH, THIRD
# mean leaf width per blade
df.bio <- mutate(df.bio, mean_leaf_width_perblade = rowMeans(select(df.bio, starts_with("leaf_width")), na.rm = TRUE))

# max leaf width per plant
df.bio$max_leaf_width_perplant = apply(df.bio[, 12:21], 1, max, na.rm = TRUE) # ignore warning messages

# after all of that, we no longer need lengths for individual blades...
colnames(df.bio) # find which columns to delete in bulk
df.bio <- df.bio[, -c(12:21)] # delete columns



# RHIZOMES and NODES, let's deal with those.
# mean node length per plant
df.bio <- mutate(df.bio, mean_node_length = rowMeans(select(df.bio, starts_with("node")), na.rm = TRUE))

# not all rhizomes were 5 cm, need to standardize Find rhizome mass per cm
df.bio <- df.bio %>% 
  mutate(rhi_mass_dw_percm = rhi_mass_dw / rhi_length, na.rm = TRUE)
df.bio <- within(df.bio, rm(na.rm))
str(df.bio)




# find total nodes per rhizome segment
nodes_only <- df.bio %>% 
  select(node1, node2, node3, node4, node5)

df.bio <- df.bio %>%
  mutate(tot_nodes = rowSums(nodes_only!=0, na.rm = TRUE)) %>%
  mutate(node1_dw = (node1 / rhi_length) * rhi_mass_dw, na.rm = TRUE) %>%
  mutate(node2_dw = (node2 / rhi_length) * rhi_mass_dw, na.rm = TRUE) %>%
  mutate(node3_dw = (node3 / rhi_length) * rhi_mass_dw, na.rm = TRUE) %>%
  mutate(node4_dw = (node4 / rhi_length) * rhi_mass_dw, na.rm = TRUE) %>%
  mutate(node5_dw = (node5 / rhi_length) * rhi_mass_dw, na.rm = TRUE) %>%
  select(-na.rm)
  
# rename node length variables for clarity
colnames(df.bio)[which(names(df.bio) == "node1")] <- "node1_length"
colnames(df.bio)[which(names(df.bio) == "node2")] <- "node2_length"
colnames(df.bio)[which(names(df.bio) == "node3")] <- "node3_length"
colnames(df.bio)[which(names(df.bio) == "node4")] <- "node4_length"
colnames(df.bio)[which(names(df.bio) == "node5")] <- "node5_length"
colnames(df.bio)

rm(nodes_only)



# there are some values that show up as non-numeric or zeros when they should be NA (consistent rows)...fixing those! 
df.bio[293:295,"mean_leaf_area_perblade"] = NA
df.bio[663,"mean_leaf_area_perblade"] = NA
df.bio[680,"mean_leaf_area_perblade"] = NA
df.bio[704:705,"mean_leaf_area_perblade"] = NA

df.bio[293:295,"tot_leaf_area_perplant"] = NA
df.bio[663,"tot_leaf_area_perplant"] = NA
df.bio[680,"tot_leaf_area_perplant"] = NA
df.bio[704:705,"tot_leaf_area_perplant"] = NA

df.bio[293:295,"mean_leaf_length_perplant"] = NA
df.bio[663,"mean_leaf_length_perplant"] = NA
df.bio[680,"mean_leaf_length_perplant"] = NA
df.bio[704:705,"mean_leaf_length_perplant"] = NA

df.bio[293:295,"max_leaf_length_perplant"] = NA
df.bio[663,"max_leaf_length_perplant"] = NA
df.bio[680,"max_leaf_length_perplant"] = NA
df.bio[704:705,"max_leaf_length_perplant"] = NA

df.bio[293:295,"mean_leaf_width_perblade"] = NA
df.bio[663,"mean_leaf_width_perblade"] = NA
df.bio[680,"mean_leaf_width_perblade"] = NA
df.bio[704:705,"mean_leaf_width_perblade"] = NA

df.bio[293:295,"max_leaf_width_perplant"] = NA
df.bio[663,"max_leaf_width_perplant"] = NA
df.bio[680,"max_leaf_width_perplant"] = NA
df.bio[704:705,"max_leaf_width_perplant"] = NA

df.bio[293:295,"mean_node_length"] = NA
df.bio[663,"mean_node_length"] = NA
df.bio[680,"mean_node_length"] = NA
df.bio[704:705,"mean_node_length"] = NA

df.bio[293:295,"tot_nodes"] = NA
df.bio[663,"tot_nodes"] = NA
df.bio[680,"tot_nodes"] = NA
df.bio[704:705,"tot_nodes"] = NA

# check the overall structure of df.bio
str(df.bio) 
```




```{r, include = FALSE}
### 2. Reshape DFs: prep each DF for site-level replication for analysis
```

* df.sedpit ---> df.sedpit2 (sediment + pit data sumed/averaged across transects within a site)
```{r, include = FALSE}
# calculate sum of all pits per site
pits_all <- df.sedpit %>% 
  select(site, date, pit_bin) # takes only the pit data from DF

m.pits_all <- melt(pits_all, id = 1:2, na.rm = TRUE) # prepares temporary DF for breakdown using dcast

trim_pits <- dcast(m.pits_all, site + date ~ ., sum) # sums all pits per site, trimming class info to just site and date
colnames(trim_pits)[which(names(trim_pits) == ".")] <- "pits_tot_site" # give data column appropriate name



# average all primary sediment values within each site
sed1_all <- df.sedpit %>% 
  select(site, date, sed1_no)

m.sed1_all <- melt(sed1_all, id = 1:2, na.rm = TRUE)

trim_sed1 <- dcast(m.sed1_all, site + date ~ ., mean)
colnames(trim_sed1)[which(names(trim_sed1) == ".")] <- "sed1_site"




# average all secondary sediment values per site
sed2_all <- df.sedpit %>% 
  select(site, date, sed2_no)

m.sed2_all <- melt(sed2_all, id = 1:2, na.rm = TRUE)

trim_sed2 <- dcast(m.sed2_all, site + date ~ ., mean)
colnames(trim_sed2)[which(names(trim_sed2) == ".")] <- "sed2_site"




# joining manipulated sub-DFs back together
df.sedpit2 <- left_join(trim_pits, trim_sed1, by = c("site", "date"))
df.sedpit2 <- left_join(df.sedpit2, trim_sed2, by = c("site", "date"))

# find the mean of the primary and secondary sediment types for later analysis
df.sedpit2$sedmean_site <- rowMeans(subset(df.sedpit2, select = c(sed1_site, sed2_site)), na.rm = TRUE)


# remove [now] extra dataframes to keep working space clean
rm(pits_all, m.pits_all, sed1_all, m.sed1_all, sed2_all, m.sed2_all, trim_pits, trim_sed1, trim_sed2)
```

* df.sedpit ---> df.sedpit_trans (reshapes sed + pit data to conserve transect structure within site)
```{r, include = FALSE}
# calculate sum of all pits per transect, within each site
pits_trans <- df.sedpit %>% 
  select(site, date, trans_type, pit_bin) # takes only the pit data from DF, per transect

m.pits_trans <- melt(pits_trans, id = 1:3, na.rm = TRUE) # prepares temporary DF for breakdown using dcast

trim_pits_trans <- dcast(m.pits_trans, site + date + trans_type ~ ., sum) # sums all pits per site, trimming class info to just site and date
colnames(trim_pits_trans)[which(names(trim_pits_trans) == ".")] <- "pits_trans" # give data column appropriate name



# average all primary sediment values within each site
sed1_trans <- df.sedpit %>% 
  select(site, date, trans_type, sed1_no)

m.sed1_trans <- melt(sed1_trans, id = 1:3, na.rm = TRUE)

trim_sed1_trans <- dcast(m.sed1_trans, site + date + trans_type ~ ., mean)
colnames(trim_sed1_trans)[which(names(trim_sed1_trans) == ".")] <- "sed1_trans"




# average all secondary sediment values per site
sed2_trans <- df.sedpit %>% 
  select(site, date, trans_type, sed2_no)

m.sed2_trans <- melt(sed2_trans, id = 1:3, na.rm = TRUE)

trim_sed2_trans <- dcast(m.sed2_trans, site + date + trans_type ~ ., mean)
colnames(trim_sed2_trans)[which(names(trim_sed2_trans) == ".")] <- "sed2_trans"




# use dcast to expand the 'trans_type' column, so that each transect has it's own row for each variable (this is necessary for later looking at just the inside transect for biomass stuff)

# pits
c.pits_trans <- dcast(trim_pits_trans, site + date ~ trans_type) # dcast spread
colnames(c.pits_trans)[which(names(c.pits_trans) == "Edge")] <- "pits_edge" # apply unique names
colnames(c.pits_trans)[which(names(c.pits_trans) == "Inside")] <- "pits_in"
colnames(c.pits_trans)[which(names(c.pits_trans) == "Outside")] <- "pits_out"


# sed1
c.sed1_trans <- dcast(trim_sed1_trans, site + date ~ trans_type)
colnames(c.sed1_trans)[which(names(c.sed1_trans) == "Edge")] <- "sed1_edge"
colnames(c.sed1_trans)[which(names(c.sed1_trans) == "Inside")] <- "sed1_in"
colnames(c.sed1_trans)[which(names(c.sed1_trans) == "Outside")] <- "sed1_out"


# sed1
c.sed2_trans <- dcast(trim_sed2_trans, site + date ~ trans_type)
colnames(c.sed2_trans)[which(names(c.sed2_trans) == "Edge")] <- "sed2_edge"
colnames(c.sed2_trans)[which(names(c.sed2_trans) == "Inside")] <- "sed2_in"
colnames(c.sed2_trans)[which(names(c.sed2_trans) == "Outside")] <- "sed2_out"




# joining manipulated sub-DFs back together
df.sedpit_trans <- left_join(c.pits_trans, c.sed1_trans, by = c("site", "date"))
df.sedpit_trans <- left_join(df.sedpit_trans, c.sed2_trans, by = c("site", "date"))



# find the means of the primary and secondary sediments for later analysis
df.sedpit_trans$sedmean_edge <- rowMeans(subset(df.sedpit_trans, select = c(sed1_edge, sed2_edge)), na.rm = TRUE)
df.sedpit_trans$sedmean_in <- rowMeans(subset(df.sedpit_trans, select = c(sed1_in, sed2_in)), na.rm = TRUE)
df.sedpit_trans$sedmean_out <- rowMeans(subset(df.sedpit_trans, select = c(sed1_out, sed2_out)), na.rm = TRUE)


# remove [now] extra dataframes to keep working space clean
rm(pits_trans, m.pits_trans, sed1_trans, m.sed1_trans, sed2_trans, m.sed2_trans, trim_pits_trans, trim_sed1_trans, trim_sed2_trans, c.pits_trans, c.sed1_trans, c.sed2_trans)
```

* df.transect --> df.transect2 (all mean site/transect data)
```{r, include=FALSE}
str(df.trans)

# calculate mean macroalgae (% cover) per site
macroalgae <- df.trans %>% 
  select(site, date, depth_m, algae_cover_m2)

m.macroalgae <- melt(macroalgae, id = 1:3, na.rm = TRUE)

trim_macroalgae <- dcast(m.macroalgae, site + date + depth_m ~ ., mean)
colnames(trim_macroalgae)[which(names(trim_macroalgae) == ".")] <- "macroalgae_percent_cover"




# calculate mean epiphyte (% cover) per site
epiphyte <- df.trans %>% 
  select(site, date, depth_m, epiphyte_cover_m2)

m.epiphyte <- melt(epiphyte, id = 1:3, na.rm = TRUE)

trim_epiphyte <- dcast(m.epiphyte, site + date + depth_m ~ ., mean)
colnames(trim_epiphyte)[which(names(trim_epiphyte) == ".")] <- "epiphyte_percent_cover"




# calculate mean shoots (per m^2) per site
shoot_count <- df.trans %>% 
  select(site, date, depth_m, seagrass_count_m2)

m.shoot_count <- melt(shoot_count, id = 1:3, na.rm = TRUE)

trim_shoot_count <- dcast(m.shoot_count, site + date + depth_m ~ ., mean)
colnames(trim_shoot_count)[which(names(trim_shoot_count) == ".")] <- "shoot_density_m2"




# calculate mean shoots (per m^2) per site
flower_count <- df.trans %>% 
  select(site, date, depth_m, flower_count_m2)

m.flower_count <- melt(flower_count, id = 1:3, na.rm = TRUE)

trim_flower_count <- dcast(m.flower_count, site + date + depth_m ~ ., mean)
colnames(trim_flower_count)[which(names(trim_flower_count) == ".")] <- "flower_density_m2"





# MERGING back together
df.trans2 <- left_join(trim_macroalgae, trim_epiphyte, by = c("site", "date", "depth_m"))
df.trans2 <- left_join(df.trans2, trim_shoot_count, by = c("site", "date", "depth_m"))
df.trans2 <- left_join(df.trans2, trim_flower_count, by = c("site", "date", "depth_m"))


# remove extra DFs to keep working space clean
rm(macroalgae, m.macroalgae, epiphyte, m.epiphyte, shoot_count, m.shoot_count, flower_count, m.flower_count, trim_epiphyte, trim_macroalgae, trim_flower_count, trim_shoot_count)
```

* df.bio --> df.bio2 (all mean biometric data seagrass)
```{r, include = FALSE}
colnames(df.bio)

########## there are a lot of variables...let's do this by tissue type. 

# leaves + epiphytes first
epiphyte_mass <- df.bio %>% 
  select(site, date, epiphyte_mass_dw)

m.epiphyte_mass <- melt(epiphyte_mass, id = 1:2, na.rm = TRUE)

trim_epiphyte_mass <- dcast(m.epiphyte_mass, site + date ~ ., mean)
colnames(trim_epiphyte_mass)[which(names(trim_epiphyte_mass) == ".")] <- "epiphyte_mass_perplant"




shoot_mass <- df.bio %>% 
  select(site, date, shoot_mass_dw)

m.shoot_mass <- melt(shoot_mass, id = 1:2, na.rm = TRUE)

trim_shoot_mass <- dcast(m.shoot_mass, site + date ~ ., mean)
colnames(trim_shoot_mass)[which(names(trim_shoot_mass) == ".")] <- "shoot_mass_perplant"




leaf_area_blade <- df.bio %>% 
  select(site, date, mean_leaf_area_perblade)

m.leaf_area_blade <- melt(leaf_area_blade, id = 1:2, na.rm = TRUE)

trim_leaf_area_blade <- dcast(m.leaf_area_blade, site + date ~ ., mean)
colnames(trim_leaf_area_blade)[which(names(trim_leaf_area_blade) == ".")] <- "leaf_area_blade"




leaf_area_plant <- df.bio %>% 
  select(site, date, tot_leaf_area_perplant)

m.leaf_area_plant <- melt(leaf_area_plant, id = 1:2, na.rm = TRUE)

trim_leaf_area_plant <- dcast(m.leaf_area_plant, site + date ~ ., mean)
colnames(trim_leaf_area_plant)[which(names(trim_leaf_area_plant) == ".")] <- "leaf_area_plant"




leaf_length_mean <- df.bio %>% 
  select(site, date, mean_leaf_length_perplant)

m.leaf_length_mean <- melt(leaf_length_mean, id = 1:2, na.rm = TRUE)

trim_leaf_length_mean <- dcast(m.leaf_length_mean, site + date ~ ., mean)
colnames(trim_leaf_length_mean)[which(names(trim_leaf_length_mean) == ".")] <- "leaf_length_mean"




leaf_length_max <- df.bio %>% 
  select(site, date, max_leaf_length_perplant)

m.leaf_length_max <- melt(leaf_length_max, id = 1:2, na.rm = TRUE)

trim_leaf_length_max <- dcast(m.leaf_length_max, site + date ~ ., mean)
colnames(trim_leaf_length_max)[which(names(trim_leaf_length_max) == ".")] <- "leaf_length_max"




leaf_width_mean <- df.bio %>% 
  select(site, date, mean_leaf_width_perblade)

m.leaf_width_mean <- melt(leaf_width_mean, id = 1:2, na.rm = TRUE)

trim_leaf_width_mean <- dcast(m.leaf_width_mean, site + date ~ ., mean)
colnames(trim_leaf_width_mean)[which(names(trim_leaf_width_mean) == ".")] <- "leaf_width_mean"




leaf_width_max <- df.bio %>% 
  select(site, date, max_leaf_width_perplant)

m.leaf_width_max <- melt(leaf_width_max, id = 1:2, na.rm = TRUE)

trim_leaf_width_max <- dcast(m.leaf_width_max, site + date ~ ., mean)
colnames(trim_leaf_width_max)[which(names(trim_leaf_width_max) == ".")] <- "leaf_width_max"





# Join back together
df.bio2 <- left_join(trim_epiphyte_mass, trim_shoot_mass, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_leaf_area_blade, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_leaf_area_plant, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_leaf_length_max, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_leaf_length_mean, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_leaf_width_max, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_leaf_width_mean, by = c("site", "date"))


# need to standardize epiphyte mass per blade area; there is a weak, positive relationship between epiphyte mass per plant and leaf area per plant. 
df.bio2 <- df.bio2 %>%
  mutate(epi_mass_leafarea_mg.cm2 = (epiphyte_mass_perplant*1000) / leaf_area_plant)


# remove extra DFs to keep working space clean
rm(epiphyte_mass, m.epiphyte_mass, trim_epiphyte_mass, leaf_area_blade, leaf_area_plant, leaf_length_max, leaf_length_mean, leaf_width_max, leaf_width_mean, m.leaf_area_blade, m.leaf_area_plant, m.leaf_length_max, m.leaf_length_mean, m.leaf_width_max, m.leaf_width_mean, trim_leaf_area_blade, trim_leaf_area_plant, trim_leaf_length_max, trim_leaf_length_mean, trim_leaf_width_max, trim_leaf_width_mean, shoot_mass, m.shoot_mass, trim_shoot_mass)


# check DF
str(df.bio2)
```

```{r, include=FALSE}
colnames(df.bio)


rhi_length <- df.bio %>% 
  select(site, date, rhi_length)

m.rhi_length <- melt(rhi_length, id = 1:2, na.rm = TRUE)

trim_rhi_length <- dcast(m.rhi_length, site + date ~ ., mean)
colnames(trim_rhi_length)[which(names(trim_rhi_length) == ".")] <- "rhi_length"




rhi_mass_tot <- df.bio %>% 
  select(site, date, rhi_mass_dw)

m.rhi_mass_tot <- melt(rhi_mass_tot, id = 1:2, na.rm = TRUE)

trim_rhi_mass_tot <- dcast(m.rhi_mass_tot, site + date ~ ., mean)
colnames(trim_rhi_mass_tot)[which(names(trim_rhi_mass_tot) == ".")] <- "rhi_mass_tot"





rhi_mass_percm <- df.bio %>% 
  select(site, date, rhi_mass_dw_percm)

m.rhi_mass_percm <- melt(rhi_mass_percm, id = 1:2, na.rm = TRUE)

trim_rhi_mass_percm <- dcast(m.rhi_mass_percm, site + date ~ ., mean)
colnames(trim_rhi_mass_percm)[which(names(trim_rhi_mass_percm) == ".")] <- "rhi_mass_percm"






node1_length <- df.bio %>% 
  select(site, date, node1_length)

m.node1_length <- melt(node1_length, id = 1:2, na.rm = TRUE)

trim_node1_length <- dcast(m.node1_length, site + date ~ ., mean)
colnames(trim_node1_length)[which(names(trim_node1_length) == ".")] <- "node1_length"




node2_length <- df.bio %>% 
  select(site, date, node2_length)

m.node2_length <- melt(node2_length, id = 1:2, na.rm = TRUE)

trim_node2_length <- dcast(m.node2_length, site + date ~ ., mean)
colnames(trim_node2_length)[which(names(trim_node2_length) == ".")] <- "node2_length"




node3_length <- df.bio %>% 
  select(site, date, node3_length)

m.node3_length <- melt(node3_length, id = 1:2, na.rm = TRUE)

trim_node3_length <- dcast(m.node3_length, site + date ~ ., mean)
colnames(trim_node3_length)[which(names(trim_node3_length) == ".")] <- "node3_length"




node4_length <- df.bio %>% 
  select(site, date, node4_length)

m.node4_length <- melt(node4_length, id = 1:2, na.rm = TRUE)

trim_node4_length <- dcast(m.node4_length, site + date ~ ., mean)
colnames(trim_node4_length)[which(names(trim_node4_length) == ".")] <- "node4_length"




node5_length <- df.bio %>% 
  select(site, date, node5_length)

m.node5_length <- melt(node5_length, id = 1:2, na.rm = TRUE)

trim_node5_length <- dcast(m.node5_length, site + date ~ ., mean)
colnames(trim_node5_length)[which(names(trim_node5_length) == ".")] <- "node5_length"




node1_dw <- df.bio %>% 
  select(site, date, node1_dw)

m.node1_dw <- melt(node1_dw, id = 1:2, na.rm = TRUE)

trim_node1_dw <- dcast(m.node1_dw, site + date ~ ., mean)
colnames(trim_node1_dw)[which(names(trim_node1_dw) == ".")] <- "node1_dw"




node2_dw <- df.bio %>% 
  select(site, date, node2_dw)

m.node2_dw <- melt(node2_dw, id = 1:2, na.rm = TRUE)

trim_node2_dw <- dcast(m.node2_dw, site + date ~ ., mean)
colnames(trim_node2_dw)[which(names(trim_node2_dw) == ".")] <- "node2_dw"




node3_dw <- df.bio %>% 
  select(site, date, node3_dw)

m.node3_dw <- melt(node3_dw, id = 1:2, na.rm = TRUE)

trim_node3_dw <- dcast(m.node3_dw, site + date ~ ., mean)
colnames(trim_node3_dw)[which(names(trim_node3_dw) == ".")] <- "node3_dw"




node4_dw <- df.bio %>% 
  select(site, date, node4_dw)

m.node4_dw <- melt(node4_dw, id = 1:2, na.rm = TRUE)

trim_node4_dw <- dcast(m.node4_dw, site + date ~ ., mean)
colnames(trim_node4_dw)[which(names(trim_node4_dw) == ".")] <- "node4_dw"




node5_dw <- df.bio %>% 
  select(site, date, node5_dw)

m.node5_dw <- melt(node5_dw, id = 1:2, na.rm = TRUE)

trim_node5_dw <- dcast(m.node5_dw, site + date ~ ., mean)
colnames(trim_node5_dw)[which(names(trim_node5_dw) == ".")] <- "node5_dw"








# MERGING back together
df.bio2 <- left_join(df.bio2, trim_rhi_length, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_rhi_mass_tot, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_rhi_mass_percm, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node1_dw, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node2_dw, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node3_dw, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node4_dw, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node5_dw, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node1_length, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node2_length, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node3_length, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node4_length, by = c("site", "date"))
df.bio2 <- left_join(df.bio2, trim_node5_length, by = c("site", "date"))



# remove extra DFs to keep working space clean
rm(rhi_length, rhi_mass_tot, rhi_mass_percm, node1_length, node2_length, node3_length, node4_length, node5_length, node1_dw, node2_dw, node3_dw, node4_dw, node5_dw, m.rhi_length, m.rhi_mass_tot, m.rhi_mass_percm, m.node1_length, m.node2_length, m.node3_length, m.node4_length, m.node5_length, m.node1_dw, m.node2_dw, m.node3_dw, m.node4_dw, m.node5_dw, trim_rhi_length, trim_rhi_mass_tot, trim_rhi_mass_percm, trim_node1_length, trim_node1_dw, trim_node2_length, trim_node2_dw, trim_node3_length, trim_node3_dw, trim_node4_length, trim_node4_dw, trim_node5_length, trim_node5_dw)




# check DF
str(df.bio2)
```

* df.bio --> df.mass_area (calculates mean masses per area data)
```{r, include = FALSE}

# extract shoot biomass and reshape to quadrat for working with count data
shoot_mass_perp <- df.bio %>% 
  select(site, date, quadrat, shoot_mass_dw)

m.shoot_mass_perp <- melt(shoot_mass_perp, id = 1:3, na.rm = TRUE)

trim_shoot_mass_perp <- dcast(m.shoot_mass_perp, site + date + quadrat ~ ., mean)
colnames(trim_shoot_mass_perp)[which(names(trim_shoot_mass_perp) == ".")] <- "shoot_mass_perp"



# extract rhizome biomass and reshape to quadrat for working with count data
rhizome_mass_percm_perp <- df.bio %>% 
  select(site, date, quadrat, rhi_mass_dw_percm)

m.rhizome_mass_percm_perp <- melt(rhizome_mass_percm_perp, id = 1:3, na.rm = TRUE)

trim_rhizome_mass_percm_perp <- dcast(m.rhizome_mass_percm_perp, site + date + quadrat ~ ., mean)
colnames(trim_rhizome_mass_percm_perp)[which(names(trim_rhizome_mass_percm_perp) == ".")] <- "rhizome_mass_percm_perp"



# gather shoot count data
shoot_count_perm <- df.trans %>% 
  select(site, date, quadrat, seagrass_count_m2)



# join shoot and rhizome masses + shoot counts
mass.temp <- left_join(trim_rhizome_mass_percm_perp, trim_shoot_mass_perp, by = c("site", "date", "quadrat"))
mass.temp <- left_join(mass.temp, shoot_count_perm, by = c("site", "quadrat"))

mass.temp <- within(mass.temp, rm(date.y))
colnames(mass.temp)[which(names(mass.temp) == "date.x")] <- "date"

# remove extra DFs to keep working space clean
rm(shoot_mass_perp, m.shoot_mass_perp, trim_shoot_mass_perp, rhizome_mass_percm_perp, m.rhizome_mass_percm_perp, trim_rhizome_mass_percm_perp, shoot_count_perm)





# calculate the masses per area per quadrat! 
mass.temp <- mass.temp %>%
  mutate(shoot_mass_m2 = shoot_mass_perp * seagrass_count_m2, na.rm = TRUE) %>%
  mutate(rhi_mass_percm_m2 = rhizome_mass_percm_perp * seagrass_count_m2, na.rm = TRUE)



#################################################################################
# testing calc of sd per variable in prep for weighted regression
sd.shootmass <- ddply(mass.temp,~site,summarise,mean=mean(shoot_mass_m2),sd=sd(shoot_mass_m2))

# extract standard deviations from shoot_mass_m2
shoot_mass_m2_sd <- sd.shootmass %>%
  select(site, sd)
colnames(shoot_mass_m2_sd)[which(names(shoot_mass_m2_sd) == "sd")] <- "shoot_mass_m2_sd"



# testing calc of sd per variable in prep for weighted regression
sd.rhimass <- ddply(mass.temp,~site,summarise,mean=mean(rhi_mass_percm_m2),sd=sd(rhi_mass_percm_m2))

# extract standard deviations from shoot_mass_m2
rhi_mass_percm_m2_sd <- sd.rhimass %>%
  select(site, sd)
colnames(rhi_mass_percm_m2_sd)[which(names(rhi_mass_percm_m2_sd) == "sd")] <- "rhi_mass_percm_m2_sd"
################################################################################



# extract biomass and reshape to quadrat for working with count data
shoot_mass_m2 <- mass.temp %>% 
  select(site, date, quadrat, shoot_mass_m2)

m.shoot_mass_m2 <- melt(shoot_mass_m2, id = 1:3, na.rm = TRUE)

trim_shoot_mass_m2 <- dcast(m.shoot_mass_m2, site + date ~ ., mean)
colnames(trim_shoot_mass_m2)[which(names(trim_shoot_mass_m2) == ".")] <- "shoot_mass_m2"



rhi_mass_percm_m2 <- mass.temp %>% 
  select(site, date, quadrat, rhi_mass_percm_m2)

m.rhi_mass_percm_m2 <- melt(rhi_mass_percm_m2, id = 1:3, na.rm = TRUE)

trim_rhi_mass_percm_m2 <- dcast(m.rhi_mass_percm_m2, site + date ~ ., mean)
colnames(trim_rhi_mass_percm_m2)[which(names(trim_rhi_mass_percm_m2) == ".")] <- "rhi_mass_percm_m2"

rm(shoot_mass_m2, m.shoot_mass_m2, rhi_mass_percm_m2, m.rhi_mass_percm_m2)



# join shoot and rhizome masses + shoot counts...and sd values for shoot_mass_m2
colnames(mass.temp)

df.mass_area <- left_join(trim_rhi_mass_percm_m2, trim_shoot_mass_m2, by = c("site", "date"))
df.mass_area <- left_join(df.mass_area, shoot_mass_m2_sd, by = c("site"))
df.mass_area <- left_join(df.mass_area, rhi_mass_percm_m2_sd, by = c("site"))

rm(trim_rhi_mass_percm_m2, trim_shoot_mass_m2, mass.temp, shoot_mass_m2_sd, sd.shootmass, rhi_mass_percm_m2_sd,sd.rhimass)
```

* df.soi: extracts sea otter index values
```{r, include = FALSE}
# extract biomass and reshape to quadrat for working with count data
df.soi <- df.soi %>% 
  select(site, sea_otter_index)
colnames(df.soi)[which(names(df.soi) == "sea_otter_index")] <- "so_index"
```
<br><br><br><br>


***



#### 3. Join: Now all of the prepared DFs will be joined together to form the 'df.all', the primary DF that will be used in the following analyses.
```{r, tidy = TRUE}
df.all <- left_join(df.coords, df.trans2, by = c("site"))
df.all <- left_join(df.all, df.sedpit2, by = c("site"))
df.all <- left_join(df.all, df.sedpit_trans, by = c("site"))
df.all <- left_join(df.all, df.bio2, by = c("site"))
df.all <- left_join(df.all, df.mass_area, by = c("site"))
df.all <- left_join(df.all, df.soi, by = c("site"))
```

```{r, include = FALSE}
# get rid of extra date columns
df.all <- within(df.all, rm(date.y))
df.all <- within(df.all, rm(date.x.x))
df.all <- within(df.all, rm(date.y.y))
df.all <- within(df.all, rm(date))
colnames(df.all)[which(names(df.all) == "date.x")] <- "date"
```
<br>

We want to manipulate df.all in the following ways:

* Add a new column, where we determine Julian Day for our dates
* Reorder columns so titles for variables are easier to locate for later analysis (there are a lot of unique # variables)
* Temporarily remove some variables from the df.all (e.g. node lengths)


```{r, include = FALSE}
# what data class is the date column?
str(df.all$date) # answer: chr; character

# convert 'date' from chr to a Date class and specify current date format
df.all$date <- as.Date(df.all$date, '%m/%d/%Y')

# convert with yday into a new column "julian_date"
df.all$julian_day <- yday(df.all$date)
```

```{r, include = FALSE}
colnames(df.all)

df.all <- df.all[c('site','site_name','latitude','longitude','date','julian_day','depth_m','so_index','pits_in','pits_edge','pits_out','pits_tot_site','sed1_in','sed1_edge','sed1_out','sed2_in','sed2_edge','sed2_out','sedmean_in','sedmean_edge','sedmean_out','sed1_site','sed2_site','sedmean_site','macroalgae_percent_cover','epiphyte_percent_cover','epiphyte_mass_perplant','epi_mass_leafarea_mg.cm2','flower_density_m2','shoot_mass_perplant','shoot_density_m2','shoot_mass_m2','leaf_length_mean','leaf_length_max','leaf_width_mean','leaf_width_max','leaf_area_blade','leaf_area_plant','rhi_length','rhi_mass_tot','rhi_mass_percm','rhi_mass_percm_m2','node1_length','node2_length','node3_length','node4_length','node5_length','node1_dw','node2_dw','node3_dw','node4_dw','node5_dw','shoot_mass_m2_sd','rhi_mass_percm_m2_sd')]


# we don't need these variables, but waited this long to remove them in case we want them later. Easy recovery.
#df.all <- within(df.all, rm(shoot_mass_fw))
df.all <- df.all[, -c(39:40,43:52)] # delete rhi_length, rhi_mass_tot, and all nodes
colnames(df.all)

```

Here are the column names in the final df.all:
```{r, echo = FALSE, tidy = TRUE}
colnames(df.all)
```
<br><br><br><br><br><br>



***





#### 4. Large-scale pattern in sediment type: These maps represent the numeric ordinal data, where the circle size scales with the numeric classification (larger circle = larger numeric).
<br><br> 
```{r, include = FALSE}
# Classifications: (1) mud, (2) muddy sand, (3) sandy mud, (4) sand, (5) coarse sand, (6) pebble, (7) gravel, (8) cobble, (9) boulder, (10) reef
```

```{r, echo = FALSE, include = FALSE}
sed.table <- matrix(c('1','2','3','4','5','6','7','8','9','10', 'Mud', 'Sandy mud', 'Muddy sand', 'Sand', 'Coarse sand', 'Pebble', 'Gravel', 'Cobble', 'Boulder', 'Reef'), ncol = 2)

colnames(sed.table) <- c('Numeric Ordinal ID', 'Adjective ID')
```

##### Here is a break down of how the numbers match with the visual classifications of sediment type. Sorry about the weird format...tables are hard. 
<br>

| Numeric Ordinal ID | Adjective ID |
|-------------------:|--------------|
|                  1 | Mud          |
|                  2 | Sandy mud    |
|                  3 | Muddy sand   |
|                  4 | Sand         |
|                  5 | Coarse sand  |
|                  6 | Pebble       |
|                  7 | Gravel       |
|                  8 | Cobble       |
|                  9 | Boulder      |
|                 10 | Reef         |

<br><br> 
  
  

#### 4A. First set of maps compare primary, secondary, and their mean for the entire site (transects averaged)
##### <span style="color:red">Red: primary sediment type</span>; <span style="color:orange">Orange: secondary sediment type</span>; <span style="color:gold">Yellow: mean of primary and secondary types</span>
```{r, echo = FALSE}
map1 <- leaflet(df.all) %>% addTiles() %>% 
  addCircleMarkers(
    lng = ~longitude, lat =  ~latitude,
    radius = ~(sed1_site) * 2,
    stroke = FALSE, fillOpacity = 0.5, 
    color = ~'Red',
    label = as.character(df.all$sed1_site)
  )


map2 <- leaflet(df.all) %>% addTiles() %>% 
  addCircleMarkers(
    lng = ~longitude, lat =  ~latitude,
    radius = ~(sed2_site) * 2,
    stroke = FALSE, fillOpacity = 0.6, 
    color = ~'Orange',
    label = as.character(df.all$sed2_site)
  )


map3 <- leaflet(df.all) %>% addTiles() %>% 
  addCircleMarkers(
    lng = ~longitude, lat =  ~latitude,
    radius = ~(sedmean_site) * 2,
    stroke = FALSE, fillOpacity = 0.7, 
    color = ~'Gold',
    label = as.character(df.all$sedmean_site)
  )



tagList(
  tags$head(tags$script(
    type="text/javascript",
    src="https://cdn.rawgit.com/turban/Leaflet.Sync/master/L.Map.Sync.js"
  )),
  tags$div(style="display:inline;width:33%;float:left;",map1),
  tags$div(style="display:inline;width:33%;float:left;",map2),
  tags$div(style="display:inline;width:33%;float:left;",map3),
  onStaticRenderComplete(
    '
var leaf_widgets = Array.prototype.map.call(
  document.querySelectorAll(".leaflet"),
  function(ldiv){
    return HTMLWidgets.find("#" + ldiv.id);
  }
);

// make this easy since we know only two maps
leaf_widgets[0].sync(leaf_widgets[1]);
leaf_widgets[1].sync(leaf_widgets[0]);
'
  )
) %>%
  browsable
```
#.
<br><br><br>  



##### 4B. Second set of maps compare inside, edge, and outside sediments, across sites (mean primary and secondary).
##### <span style="color:green">Green: inside transect sediment type</span>; <span style="color:blue">Blue: edge transect sediment type</span>; <span style="color:purple">Purple: outside transect sediment type</span>
```{r, echo = FALSE}
map4 <- leaflet(df.all) %>% addTiles() %>% 
  addCircleMarkers(
    lng = ~longitude, lat =  ~latitude,
    radius = ~(sedmean_in) * 2,
    stroke = FALSE, fillOpacity = 0.5, 
    color = ~'Green',
    label = as.character(df.all$sedmean_in)
  )


map5 <- leaflet(df.all) %>% addTiles() %>% 
  addCircleMarkers(
    lng = ~longitude, lat =  ~latitude,
    radius = ~(sedmean_edge) * 2,
    stroke = FALSE, fillOpacity = 0.5, 
    color = ~'Blue',
    label = as.character(df.all$sedmean_edge)
  )


map6 <- leaflet(df.all) %>% addTiles() %>% 
  addCircleMarkers(
    lng = ~longitude, lat =  ~latitude,
    radius = ~(sedmean_out) * 2,
    stroke = FALSE, fillOpacity = 0.5, 
    color = ~'Purple',
    label = as.character(df.all$sedmean_out)
  )



tagList(
  tags$head(tags$script(
    type="text/javascript",
    src="https://cdn.rawgit.com/turban/Leaflet.Sync/master/L.Map.Sync.js"
  )),
  tags$div(style="display:inline;width:33%;float:left;",map4),
  tags$div(style="display:inline;width:33%;float:left;",map5),
  tags$div(style="display:inline;width:33%;float:left;",map6),
  onStaticRenderComplete(
'
var leaf_widgets = Array.prototype.map.call(
  document.querySelectorAll(".leaflet"),
  function(ldiv){
    return HTMLWidgets.find("#" + ldiv.id);
  }
);

// make this easy since we know only two maps
leaf_widgets[0].sync(leaf_widgets[1]);
leaf_widgets[1].sync(leaf_widgets[0]);
'
  )
) %>%
  browsable
```
#.
<br><br><br>



##### 4C. Third set of maps compare #pits dug at inside, edge, and outside transects (larger circle = more pits).
##### <span style="color:black">Black: inside transect total pits</span>; <span style="color:darkred">Red: edge transect total pits</span>; <span style="color:darkblue">Blue: outside transect total pits</span>
```{r, echo = FALSE}
map7 <- leaflet(df.all) %>% addTiles() %>% 
  addCircleMarkers(
    lng = ~longitude, lat =  ~latitude,
    radius = ~log(pits_in) * 3,
    stroke = FALSE, fillOpacity = 0.5, 
    color = ~'Black',
    label = as.character(df.all$pits_in)
  )


map8 <- leaflet(df.all) %>% addTiles() %>% 
  addCircleMarkers(
    lng = ~longitude, lat =  ~latitude,
    radius = ~log(pits_edge) * 3,
    stroke = FALSE, fillOpacity = 0.5, 
    color = ~'DarkRed',
    label = as.character(df.all$pits_edge)
  )


map9 <- leaflet(df.all) %>% addTiles() %>% 
  addCircleMarkers(
    lng = ~longitude, lat =  ~latitude,
    radius = ~log(pits_out) * 3,
    stroke = FALSE, fillOpacity = 0.5, 
    color = ~'DarkBlue',
    label = as.character(df.all$pits_out)
  )



tagList(
  tags$head(tags$script(
    type="text/javascript",
    src="https://cdn.rawgit.com/turban/Leaflet.Sync/master/L.Map.Sync.js"
  )),
  tags$div(style="display:inline;width:33%;float:left;",map7),
  tags$div(style="display:inline;width:33%;float:left;",map8),
  tags$div(style="display:inline;width:33%;float:left;",map9),
  onStaticRenderComplete(
'
var leaf_widgets = Array.prototype.map.call(
  document.querySelectorAll(".leaflet"),
  function(ldiv){
    return HTMLWidgets.find("#" + ldiv.id);
  }
);

// make this easy since we know only two maps
leaf_widgets[0].sync(leaf_widgets[1]);
leaf_widgets[1].sync(leaf_widgets[0]);
'
  )
) %>%
  browsable
```
#.
<br><br><br><br>




#### 4D. Regression of sediment versus sea otter index
```{r, include = FALSE}

# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# rhi_mass_percm_m2
p27 = ggplot(df.all, aes(so_index, sed1_site)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Sea otter index\n")+ylab("\nPrimary sediment class (site)") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p27)


# look at fit of linear regression: density, qq-norm
m1 <- lm(sedmean_site ~ so_index, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 
```

```{r, include = FALSE}
colnames(df.all)

# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# rhi_mass_percm_m2
p28 = ggplot(df.all, aes(so_index, sedmean_site)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Sea otter index\n")+ylab("\nMean sediment class (site)") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p28)


# look at fit of linear regression: density, qq-norm
m1 <- lm(sedmean_site ~ so_index, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 
```
<br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
plot_grid(p27, p28, labels=c('A', 'B'), align = 'h', ncol=2, nrow=1, rel_widths = c(3.5, 3.5))
```
<br><br><br><br><br><br><br>












***

### 5. Exploratory analysis

<br><br>

#### Regressions: use sediment or pit values as independent factors
<br>

There are a lot of possible plots using df.all. Tiff looked at the regressions for all of those plots but only includes results for regressions that look significant, or might with either transformation or non-linear regression. 

<br><br>

#### 5A. Aboveground biomass:
```{r, include = FALSE}
colnames(df.all)

# optional manipulation of specified values; for example, might want to convert 0s to NA in some instances
#df.all[, 9:12][df.all[, 9:12] == 0] <- NA 



# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# shoot_mass_m2
p1 = ggplot(df.all, aes(sedmean_site, shoot_mass_m2, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Mean sediment class (site)\n")+ylab("\nAG biomass (g per msq, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p1)






# extract julian_day residuals for this independent variable
m.julian.shoot_mass_m2 <- lm(shoot_mass_m2 ~ julian_day, data = df.all)
r.julian.shoot_mass_m2 <- resid(m.julian.shoot_mass_m2)


# shoot_mass_m2 w/ julian_day residuals
p2 = ggplot(df.all, aes(sedmean_site, r.julian.shoot_mass_m2, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Mean sediment class (site)\n")+ylab("\nResiduals: AG biomass x julian (g per msq, DW)") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p2)





# look at fit of linear regression: density, qq-norm
m1 <- lm(shoot_mass_m2 ~ sed1_site, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 


###### STEPS FOR WEIGHTED REGRESSION ANALYSIS

# linear regression
#ln.m1 <- lm(shoot_mass_m2 ~ julian_day, data = df.all)
#summary(ln.m1)

# weighted regression NEED RESIDUALS FOR EACH DEPENDENT POINT
#wt.shoot_mass_m2_sd <- 1/(df.all$shoot_mass_m2_sd)^2
#wt.m1 <- lm(shoot_mass_m2 ~ julian_day, weights = wt.shoot_mass_m2_sd, data = df.all)
#summary(wt.m1)

# plot the data and the best fit model using weighted residuals
#plot(shoot_mass_m2 ~ julian_day, data = df.all)
#lines(df.all$julian_day, predict(ln.m1), col = 'blue')
#lines(df.all$julian_day, predict(wt.m1), col = 'red')
```

```{r, include = FALSE}
# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# shoot_mass_m2
p3 = ggplot(df.all, aes(sed1_in, shoot_mass_m2, color = so_index)) +
  geom_point(size=3) +
 # geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Primary sediment class (inside transect)\n")+ylab("\nAG biomass (g per msq, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p3)






# extract julian_day residuals for this independent variable
m.julian.shoot_mass_m2 <- lm(shoot_mass_m2 ~ julian_day, data = df.all)
r.julian.shoot_mass_m2 <- resid(m.julian.shoot_mass_m2)


# shoot_mass_m2 w/ julian_day residuals
p4 = ggplot(df.all, aes(sed1_in, r.julian.shoot_mass_m2, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Primary sediment class (inside transect)\n")+ylab("\nResiduals: AG biomass x julian (g per msq, DW)") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p4)



```
<br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp1 <- ggdraw() + draw_label("Aboveground biomass * mean sediment class, whole site", fontface='bold')

cp1 <- plot_grid(p1, p2, labels=c('A', 'B'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp1, cp1, ncol=1, rel_heights=c(0.1, 1))
```
<br><br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp2 <- ggdraw() + draw_label("Aboveground biomass * primary sediment class, inside transect", fontface='bold')

cp2 <- plot_grid(p3, p4, labels=c('C', 'D'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp2, cp2, ncol=1, rel_heights=c(0.1, 1))
```
<br><br><br><br><br><br>









#### 5B. Belowground biomass (biomass rhizome per cm, per msq):
```{r, include = FALSE}
colnames(df.all)

# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# rhi_mass_percm_m2
p5 = ggplot(df.all, aes(sedmean_site, log(rhi_mass_percm_m2), color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Mean sediment class (site)\n")+ylab("\nlog(BG biomass per cm rhizome (g per msq, DW))") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p5)


# look at fit of linear regression: density, qq-norm
m1 <- lm(log(rhi_mass_percm_m2) ~ sedmean_site, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# extract julian_day residuals for this independent variable
m.julian.rhi_mass_percm_m2 <- lm(log(rhi_mass_percm_m2) ~ julian_day, data = df.all)
r.julian.rhi_mass_percm_m2 <- resid(m.julian.rhi_mass_percm_m2)


# rhi_mass_percm_m2 w/ julian_day residuals
p6 = ggplot(df.all, aes(sedmean_site, r.julian.rhi_mass_percm_m2, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Mean sediment class (site)\n")+ylab("\nResiduals: log(BG biomass per cm rhizome (g per msq, DW)) x julian") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p6)
```

```{r, include = FALSE}
# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# shoot_mass_m2
p7 = ggplot(df.all, aes(sed1_in, log(rhi_mass_percm_m2), color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Primary sediment class (inside transect)\n")+ylab("\nlog(BG biomass per cm rhizome (g per msq, DW))") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p7)



# look at fit of linear regression: density, qq-norm
m1 <- lm(log(rhi_mass_percm_m2) ~ sed1_in, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# extract julian_day residuals for this independent variable
m.julian.rhi_mass_percm_m2 <- lm(log(rhi_mass_percm_m2) ~ julian_day, data = df.all)
r.julian.rhi_mass_percm_m2 <- resid(m.julian.rhi_mass_percm_m2)


# shoot_mass_m2 w/ julian_day residuals
p8 = ggplot(df.all, aes(sed1_in, r.julian.shoot_mass_m2, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Primary sediment class (inside transect)\n")+ylab("\nResiduals: log(BG biomass per cm rhizome (g per msq, DW)) x julian") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p8)
```

```{r, include = FALSE}
# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# shoot_mass_m2
p9 = ggplot(df.all, aes(sed2_in, rhi_mass_percm_m2, color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Secondary sediment class (inside transect)\n")+ylab("\nBG biomass per cm rhizome (g per msq, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p9)



# look at fit of linear regression: density, qq-norm
m1 <- lm(rhi_mass_percm_m2 ~ sed2_in, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# extract julian_day residuals for this independent variable
m.julian.rhi_mass_percm_m2 <- lm(rhi_mass_percm_m2 ~ julian_day, data = df.all)
r.julian.rhi_mass_percm_m2 <- resid(m.julian.rhi_mass_percm_m2)


# shoot_mass_m2 w/ julian_day residuals
p10 = ggplot(df.all, aes(sed2_in, r.julian.rhi_mass_percm_m2, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Secondary sediment class (inside transect)\n")+ylab("\nResiduals: BG biomass per cm rhizome (g per msq, DW) x julian") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p10)
```
<br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp3 <- ggdraw() + draw_label("Belowground biomass per cm rhizome (per m2) * mean sediment class, whole site", fontface='bold')

cp3 <- plot_grid(p5, p6, labels=c('A', 'B'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp3, cp3, ncol=1, rel_heights=c(0.1, 1))
```
<br><br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp4 <- ggdraw() + draw_label("Belowground biomass per cm rhizome (per m2) * primary sediment class, inside transect", fontface='bold')

cp4 <- plot_grid(p7, p8, labels=c('C', 'D'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp4, cp4, ncol=1, rel_heights=c(0.1, 1))
```
<br><br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp5 <- ggdraw() + draw_label("Belowground biomass per cm rhizome (per m2) * secondary sediment class, inside transect", fontface='bold')

cp5 <- plot_grid(p9, p10, labels=c('E', 'F'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp5, cp5, ncol=1, rel_heights=c(0.1, 1))
```
<br><br><br><br><br><br>









#### 5C. Belowground biomass (biomass rhizome per cm):
```{r, include = FALSE}
colnames(df.all)

# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# rhi_mass_percm_m2
p11 = ggplot(df.all, aes(sedmean_site, rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Mean sediment class (site)\n")+ylab("\nBG biomass (g per cm rhizome, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p11)


# look at fit of linear regression: density, qq-norm
m1 <- lm(rhi_mass_percm ~ sedmean_site, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# extract julian_day residuals for this independent variable
m.julian.rhi_mass_percm <- lm(log(rhi_mass_percm) ~ julian_day, data = df.all)
r.julian.rhi_mass_percm <- resid(m.julian.rhi_mass_percm)


# rhi_mass_percm_m2 w/ julian_day residuals
p12 = ggplot(df.all, aes(sedmean_site, r.julian.rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Mean sediment class (site)\n")+ylab("\nResiduals: BG biomass (g per cm rhizome, DW) x julian") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p12)
```

```{r, include = FALSE}
# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# shoot_mass_m2
p13 = ggplot(df.all, aes(sed1_in, rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Primary sediment class (inside transect)\n")+ylab("\nBG biomass (g per cm rhizome, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p13)



# look at fit of linear regression: density, qq-norm
m1 <- lm(rhi_mass_percm ~ sed1_in, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# extract julian_day residuals for this independent variable
m.julian.rhi_mass_percm <- lm(rhi_mass_percm ~ julian_day, data = df.all)
r.julian.rhi_mass_percm <- resid(m.julian.rhi_mass_percm)


# shoot_mass_m2 w/ julian_day residuals
p14 = ggplot(df.all, aes(sed1_in, r.julian.rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Primary sediment class (inside transect)\n")+ylab("\nResiduals: BG biomass (g per cm rhizome, DW) x julian") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p14)
```

```{r, include = FALSE}
# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# shoot_mass_m2
p15 = ggplot(df.all, aes(sed2_in, rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Secondary sediment class (inside transect)\n")+ylab("\nBG biomass (g per cm rhizome, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p15)



# look at fit of linear regression: density, qq-norm
m1 <- lm(rhi_mass_percm_m2 ~ sed2_in, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# extract julian_day residuals for this independent variable
m.julian.rhi_mass_percm <- lm(rhi_mass_percm ~ julian_day, data = df.all)
r.julian.rhi_mass_percm <- resid(m.julian.rhi_mass_percm)


# shoot_mass_m2 w/ julian_day residuals
p16 = ggplot(df.all, aes(sed2_in, r.julian.rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Secondary sediment class (inside transect)\n")+ylab("\nResiduals: BG biomass (g per cm rhizome, DW) x julian") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p16)
```
<br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp6 <- ggdraw() + draw_label("Belowground biomass per cm rhizome * mean sediment class, whole site", fontface='bold')

cp6 <- plot_grid(p11, p12, labels=c('A', 'B'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp6, cp6, ncol=1, rel_heights=c(0.1, 1))
```
<br><br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp7 <- ggdraw() + draw_label("Belowground biomass per cm rhizome * primary sediment class, inside transect", fontface='bold')

cp7 <- plot_grid(p13, p14, labels=c('C', 'D'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp7, cp7, ncol=1, rel_heights=c(0.1, 1))
```
<br><br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp8 <- ggdraw() + draw_label("Belowground biomass per cm rhizome * secondary sediment class, inside transect", fontface='bold')

cp8 <- plot_grid(p15, p16, labels=c('E', 'F'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp8, cp8, ncol=1, rel_heights=c(0.1, 1))
```
<br><br><br><br><br><br>











#### 5D. Epiphyte biomass (per plant):
```{r, include = FALSE}
colnames(df.all)

# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# rhi_mass_percm_m2
p17 = ggplot(df.all, aes(sedmean_site, log(epiphyte_mass_perplant), color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Mean sediment class (site)\n")+ylab("\nlog(Epiphyte biomass (g per plant, DW))") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p17)


# look at fit of linear regression: density, qq-norm
m1 <- lm(log(epiphyte_mass_perplant) ~ sedmean_site, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# extract julian_day residuals for this independent variable
m.julian.epiphyte_mass_perplant <- lm(log(epiphyte_mass_perplant) ~ julian_day, data = df.all)
r.julian.epiphyte_mass_perplant <- resid(m.julian.epiphyte_mass_perplant)


# rhi_mass_percm_m2 w/ julian_day residuals
p18 = ggplot(df.all, aes(sedmean_site, r.julian.rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Mean sediment class (site)\n")+ylab("\nResiduals: log(Epiphyte biomass (g per plant, DW)) x julian") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p18)
```

```{r, include = FALSE}
# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# shoot_mass_m2
p19 = ggplot(df.all, aes(sed1_in, log(epiphyte_mass_perplant), color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Primary sediment class (inside transect)\n")+ylab("\nlog(Epiphyte biomass (g per plant, DW))") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p19)



# look at fit of linear regression: density, qq-norm
m1 <- lm(log(epiphyte_mass_perplant) ~ sed1_in, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# extract julian_day residuals for this independent variable
m.julian.epiphyte_mass_perplant <- lm(log(epiphyte_mass_perplant) ~ julian_day, data = df.all)
r.julian.epiphyte_mass_perplant <- resid(m.julian.epiphyte_mass_perplant)


# shoot_mass_m2 w/ julian_day residuals
p20 = ggplot(df.all, aes(sed1_in, r.julian.epiphyte_mass_perplant, color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Primary sediment class (inside transect)\n")+ylab("\nResiduals: log(epiphyte_mass_perplant) x julian") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p20)
```

```{r, include = FALSE}
# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# shoot_mass_m2
p21 = ggplot(df.all, aes(sedmean_edge, log(epiphyte_mass_perplant), color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Mean sediment class (edge transect)\n")+ylab("\nlog(Epiphyte biomass (g per plant, DW))") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p21)



# look at fit of linear regression: density, qq-norm
m1 <- lm(log(epiphyte_mass_perplant) ~ sedmean_edge, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# extract julian_day residuals for this independent variable
m.julian.epiphyte_mass_perplant <- lm(log(epiphyte_mass_perplant) ~ julian_day, data = df.all)
r.julian.epiphyte_mass_perplant <- resid(m.julian.epiphyte_mass_perplant)


# shoot_mass_m2 w/ julian_day residuals
p22 = ggplot(df.all, aes(sedmean_edge, r.julian.epiphyte_mass_perplant, color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  #theme(legend.justification=c(1,0), legend.position=c(1,0)) +
  xlab("Mean sediment class (edge transect)\n")+ylab("\nResiduals: BG biomass per cm rhizome x julian") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p22)
```
<br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp9 <- ggdraw() + draw_label("Epiphyte biomass * mean sediment class, whole site", fontface='bold')

cp9 <- plot_grid(p17, p18, labels=c('A', 'B'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp9, cp9, ncol=1, rel_heights=c(0.1, 1))
```
<br><br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp10 <- ggdraw() + draw_label("Epiphyte biomass * primary sediment class, inside transect", fontface='bold')

cp10 <- plot_grid(p19, p20, labels=c('C', 'D'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp10, cp10, ncol=1, rel_heights=c(0.1, 1))
```
<br><br>

```{r, echo = FALSE, fig.width = 12, fig.height = 5}
title.cp11 <- ggdraw() + draw_label("Epiphyte biomass * mean sediment class, edge transect", fontface='bold')

cp11 <- plot_grid(p21, p22, labels=c('E', 'F'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp11, cp11, ncol=1, rel_heights=c(0.1, 1))
```
<br><br><br><br><br><br>








#### 5E. Pits vs belowground biomass
```{r, include = FALSE, warning = FALSE}
colnames(df.all)


# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot


p23 = ggplot(df.all, aes(pits_tot_site, rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Total pits (site); zeros included\n")+ylab("\nBG biomass (g per cm rhizome, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p23)


# look at fit of linear regression: density, qq-norm
m1 <- lm(rhi_mass_percm ~ pits_tot_site, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# optional manipulation of specified values; for example, might want to convert 0s to NA in some instances
df.all[, 12][df.all[, 12] == 0] <- NA 


# rhi_mass_percm_m2
p24 = ggplot(df.all, aes(pits_tot_site, rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Total pits (site); zeros excluded\n")+ylab("\nBG biomass (g per cm rhizome, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p24)
```

```{r, include = FALSE, warning = FALSE}
# plotting in scatter
colnames(df.all)


# plotting in scatter
my.formula <- y ~ x # defined formula (linear regression) for stats labels on plot

# rhi_mass_percm_m2
p25 = ggplot(df.all, aes(pits_out, rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  #geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Total pits (outside transect); zeros included\n")+ylab("\nBG biomass (g per cm rhizome, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p25)


# look at fit of linear regression: density, qq-norm
m1 <- lm(rhi_mass_percm ~ pits_out, data = df.all) # create a linear model
r1 <- resid(m1) # list of model residuals
plot(density(resid(m1))) # density plot
qqnorm(resid(m1)) # quantile normal plot - good for checking normality
qqline(resid(m1))
summary(m1)

# plot the residuals against the fitted points to look at spread
ggplot(df.all, aes(fitted(m1), resid(m1))) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0) 





# optional manipulation of specified values; for example, might want to convert 0s to NA in some instances
df.all[, 11][df.all[, 11] == 0] <- NA 


# rhi_mass_percm_m2
p26 = ggplot(df.all, aes(pits_out, rhi_mass_percm, color = so_index)) +
  geom_point(size=3) +
  geom_smooth(method=lm, formula=y~x, se=FALSE, fullrange=FALSE) +
  xlab("Total pits (outside transect); zeros excluded\n")+ylab("\nBG biomass (g per cm rhizome, DW)") +
  theme(legend.position="none") +
  stat_poly_eq(formula = my.formula, 
               aes(label = paste(..rr.label.., sep = "~~~")), 
               label.x.npc = 'right', label.y.npc = 'top', size = 4, parse = TRUE) +
  stat_fit_glance(method = 'lm', method.args = list(formula = my.formula), geom = 'text',
                  aes(label = paste("P-value = ", signif(..p.value.., digits = 3), sep = "")),
                  label.x.npc = 'left', label.y.npc = 'top', size = 4)
plot(p26)
```
<br>

```{r, echo = FALSE, warning = FALSE, fig.width = 12, fig.height = 5}
title.cp12 <- ggdraw() + draw_label("Belowground biomass (g per cm rhizome, DW) * Total pits, whole site", fontface='bold')

cp12 <- plot_grid(p23, p24, labels=c('A', 'B'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp12, cp12, ncol=1, rel_heights=c(0.1, 1))
```
<br><br>

```{r, echo = FALSE, warning = FALSE, fig.width = 12, fig.height = 5}
title.cp13 <- ggdraw() + draw_label("Belowground biomass (g per cm rhizome, DW) * Total pits, outside transect", fontface='bold')

cp13 <- plot_grid(p25, p26, labels=c('C', 'D'), align = 'h', ncol=2, nrow=1, rel_widths = c(3, 3.5))

plot_grid(title.cp13, cp13, ncol=1, rel_heights=c(0.1, 1))
```
<br><br><br>

***

<br>














